#!/tools/bin/bash

set -eET

START_TIME=$(date +%F-%X)
OPTS_ORIG="$@"
: ${DEV_ROOT:=/root}
export DEV_ROOT SDKARCH=$ARCH BUILD_DIR=$DEV_ROOT/BUILD SPECS=$DEV_ROOT/SPECS \
	PKG_POOL=$DEV_ROOT/POOL FS_ROOT=$DEV_ROOT/ROOT INCDIR=$DEV_ROOT/INC GEN_DIR=$DEV_ROOT/GEN

bs_error()
{
	echo -e "!!!!!!!! Error: $@ !!!!!!!!!!" >&2
	return 1
}

bs_notice()
{
	echo -e ">>>>>>>>> $@ <<<<<<<<<<"
}

quit()
{
	bs_error "buildsys process interrupted..."
	exit 1
}

unpack()
{
	local DEST='.'
	if [ -n "$2" ]; then
		DEST="$2"
	fi
	case "$1" in
		*.tar.gz | *.tar.bz2 | *.tar.xz | *.tgz | *.tbz | *.txz)
			tar -xf "$1" -C "$DEST"
			;;
		*.zip)
			unzip "$1" -d "$DEST"
			;;
		*)
			bs_error "Unknown package format for \"$1\""
			;;
	esac
	return 0
}

guess_pkg_info()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$PKG_FILE_NAME" in
			*.tar.gz | *.tar.bz2 | *.tar.xz)
				SUFFIX="tar.$SUFFIX"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%.$SUFFIX}"
		PKG_NAME="${PKG_NAME%-*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$SRC_DIR" ]; then
		SRC_DIR="${BUILD_DIR}/${PKG}/${PKG_NAME}-${VERSION}"
	else
		SRC_DIR="${BUILD_DIR}/${PKG}/${SRC_DIR}"
	fi
}

get_file()
{
	local SOURCE="$1" DEST="$2" FILE=
	local SOURCE_FILE="${SOURCE##*/}"
	if [ -f "$DEST"/"$SOURCE_FILE" ]; then
		bs_notice "File \"$SOURCE_FILE\" already exists in \"$DEST\", skip getting"
		return
	fi
	case "$SOURCE" in
		http://* | ftp://*)
			bs_notice "Downloading ${SOURCE}"
			wget -c -O "$DEST/${SOURCE_FILE}.partial" "$SOURCE"
			mv -v "$DEST"/${SOURCE_FILE}.partial "$DEST"/$SOURCE_FILE
			;;
		*)
			for FILE in "$SOURCE" "$SPECS/$PKG/$SOURCE" ""; do
				if [ -f "$FILE" ]; then
					ln -vsf "$FILE" "$DEST" || cp -v "$FILE" "$DEST"
					break
				fi
			done
			if [ -z "$FILE" ]; then
				bs_error "File \"$SOURCE\" not found"
			fi
			;;
	esac
}

precede_conf_opts()
{
	local ARG CONFIGURE=configure
	for ARG in $@; do
		if [ "$PKG_NAME" = 'vim' ]; then
			CONFIGURE=src/auto/configure
		fi
		if ! grep -F -q -e "${ARG%=*}" $CONFIGURE; then
			bs_notice "${PKG}'s configure does not support ${ARG%=*} directive"
		else
			CONFIGFLAGS="$ARG $CONFIGFLAGS"
		fi
	done
}

export_cross_tools()
{
	local TOOL
	for TOOL in CC AR AS RANLIB LD STRIP; do
		LOWERCASE=$(echo $TOOL | tr '[:upper:]' '[:lower:]')
		export eval $TOOL=${1}-${LOWERCASE}
	done
	export CXX="${1}-g++"
}

toolchain_link()
{
	OPATH="$PATH"
	PATH=/tools/bin
	pushd /tools/bin > /dev/null
	case "$1" in
		tools)
			ln -vf ld-old ld
			rm -vf `dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		root)
			ln -vf ld-new ld
			gcc -dumpspecs | sed -e 's@/tools@@g' \
				-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
				-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
				`dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		*)
			return 1
			;;
	esac
	popd > /dev/null
	PATH="$OPATH"
}

walk_pkg_dir()
{
	SETOPTS='-eET'
	OPTIND=1
	while getopts "c" FLAG
	do
		case "$FLAG" in
			c)
				SETOPTS=''
				;;
		esac
	done
	shift $((OPTIND - 1))

	for PKG in ${BUILD_LIST[@]}; do
		export PKG
		(
		local SPECFOUND=0
		set -a $SETOPTS
		if [ $(dirname $PKG) != . ]; then
			source $INCDIR/$(dirname $PKG)
			parse_conf_var
			PKG=$(basename $PKG)
		fi
		PKG_DIR="${BUILD_DIR}/${PKG}"
		mkdir -p "$PKG_DIR"
		MAKEDIR="$PKG_DIR/build"
		for SPECFILE in "${SPECS}/${PKG}/spec" "${SPECS}/${PKG}/${SPEC_NAME}"; do
			if [ -f $SPECFILE ]; then
				bs_notice "Reading $SPECFILE"
				source $SPECFILE
				: $((SPECFOUND |= 1))
			fi
		done
		if [ $SPECFOUND = 0 ]; then
			bs_error "${PKG}'s spec not found"
		fi
		[ "$PREFIX" = /tools ] && BUILDSYS_LINK=tools
		toolchain_link $BUILDSYS_LINK
		[ -n "$PKG_LOCATION" ] && guess_pkg_info "$PKG_LOCATION"
		pushd "$PKG_DIR"
		for ACT in "$@"; do
			$ACT
		done
		popd
		)
	done
}

pkg_unpack_patch()
{
	if [ ! -f .unpacked ] && [ ! -d "${SRC_DIR}" ]; then
		if [ -z "$PKG_LOCATION" ]; then
			bs_error "No source file defined for \"$PKG\""
		fi
		if [ -d "$PKG_LOCATION" ]; then
			ln -sv "$PKG_LOCATION" "$PKG_DIR"
		else
			get_file "$PKG_LOCATION" "$PKG_POOL"
			bs_notice "Unpacking file ${PKG_FILE_NAME}"
			unpack "${PKG_POOL}/${PKG_FILE_NAME}"
		fi
		for ADDITION in ${ADDITIONS[@]}; do
			get_file "$ADDITION" "$PKG_POOL"
			bs_notice "Unpacking file ${PKG_FILE_NAME}"
			unpack "$PKG_POOL/${ADDITION##*/}" "$SRC_DIR"
		done
		touch .unpacked
	fi
	if [ ! -f .patched ]; then
		pushd "$SRC_DIR"
		for PATCH in ${PATCHES[@]}; do
			get_file "$PATCH" "$PKG_POOL"
			patch --verbose -Np1 < $PKG_POOL/${PATCH##*/}
		done
		# Execute any script or binary with env variables exported for it
		# pre-build can be used to do patching job
		# Only bash and perl supported for scripting as of now
		[ -x ${SPECS}/${PKG}/pre-build ] && ${SPECS}/${PKG}/pre-build
		popd
		touch .patched
	fi
}

pkg_make_install()
{
	if [ ! -f .built ]; then
		pushd "$SRC_DIR"
		bs_notice "Building package ${PKG} in $SRC_DIR"
		if [ -x ${SPECS}/${PKG}/build ]; then
			${SPECS}/${PKG}/build
			ln -vs "$SRC_DIR" "$MAKEDIR"
		else
			if [ -r Makefile ] && [ ! -x configure ]; then
				MAKEFLAGS="PREFIX=$PREFIX $MAKEFLAGS"
				bs_notice "Executing make with $MAKEFLAGS" "$CROSS_MAKEOPTS"
				make $MAKEFLAGS $CROSS_MAKEOPTS
				make $MAKEFLAGS $CROSS_MAKEOPTS install
				ln -vfs "$SRC_DIR" "$MAKEDIR"
			elif [ -x configure ]; then
				if [ ! -f ${PKG_DIR}/.configured ]; then
					precede_conf_opts "--prefix=$PREFIX"
					if [ -n "$BUILDSYS_BUILD" ] && [ -n "$BUILDSYS_HOST" ]; then
						precede_conf_opts "--build=$BUILDSYS_BUILD" "--host=$BUILDSYS_HOST"
					fi
					mkdir -p $MAKEDIR
					pushd $MAKEDIR
					bs_notice "Executing configure $CONFIGFLAGS"
					$SRC_DIR/configure ${CONFIGFLAGS}
					popd
					touch ${PKG_DIR}/.configured
				fi
				cd $MAKEDIR
				bs_notice "Executing make $MAKEFLAGS"
				make $MAKEFLAGS
				make $MAKEFLAGS install
			elif [ -r ${PKG_NAME}.pro ]; then
				qmake
				make
				ln -vs "$SRC_DIR" "$MAKEDIR"
			else
				bs_error "Don't know how to build package $PKG."
			fi
		fi
		popd
		touch .built
	fi
	if [ ! -f .done ]; then
		# post-install can be used to fix installation problems
		if [ -x ${SPECS}/${PKG}/post-install ]; then
			pushd /
			${SPECS}/${PKG}/post-install
			popd
		fi
		touch .done
	else
		bs_notice "${PKG} has already been built. Skip."
		return
	fi
}

pkg_make_clean()
{
	cd $MAKEDIR
	if ! grep -q '^clean:' Makefile; then
		bs_error "\"${PKG_NAME}\" does not support make clean"
	fi
	bs_notice "Cleaing \"$PKG\"..."
	make clean
	cd $PKG_DIR
	rm -f .done .built
}

pkg_make_distclean()
{
	cd $MAKEDIR
	bs_notice "Dist cleaing \"$PKG\"..."
	if grep -q '^distclean:' Makefile; then
		make distclean
	elif grep -q '^clean:' Makefile; then
		make clean
	else
		bs_error "\"${PKG_NAME}\" does not support make clean or distclean"
	fi
	cd $PKG_DIR
	rm -f .done .built .configured
}

pkg_make_uninstall()
{
	cd $MAKEDIR
	if ! grep -q '^uninstall' Makefile; then
		bs_error "Error: \"${PKG_NAME}\" does not support make uninstall"
	fi
	bs_notice "Uninstalling \"$PKG\"..."
	make uninstall
	rm -f $PKG_DIR/.done
}

pkg_make_dest_install()
{
	if [ "$TARGET_INSTALL" = n ]; then
		bs_notice "Package \"$PKG\" is not required to be installed on target."
		return
	fi
	bs_notice "Installing \"$PKG\" into ${FS_ROOT}..."
	cd $MAKEDIR
	if  fgrep -q 'DESTDIR' Makefile || [[ "$PKG_NAME" == *glibc ]] || [[ "$PKG_NAME" == vim ]]; then
		make DESTDIR=${FS_ROOT} install
	elif fgrep -q 'PREFIX' Makefile; then
		make PREFIX=${FS_ROOT}/${PREFIX} install
	fi
	# post-install can be used to fix target installation problems
	if [ -x ${SPECS}/${PKG}/post-install ]; then
		MAKEDIR="$PWD"
		pushd "$FS_ROOT"
		${SPECS}/${PKG}/post-install
		popd
	fi
}

pkg_remove()
{
	if [ -r "$PKG_POOL/$PKG_FILE_NAME" ] || [ -n "$PKG_LOCATION" ]; then
		cd ..
		bs_notice "Removing $PKG_DIR"
		rm -rf "$PKG_DIR"
	elif [ -d "$MAKEDIR" ]; then
		pkg_make_distclean
	fi
}

clean_pkgs()
{
	walk_pkg_dir pkg_make_clean
	bs_notice "Package ${BUILD_LIST[@]} clean complete."
}

distclean_pkgs()
{
	walk_pkg_dir -c pkg_make_distclean
	bs_notice "Package ${BUILD_LIST[@]} dist clean complete."
}

uninstall_pkgs()
{
	bs_notice "${BUILD_LIST[@]} are going to be uninstalled."
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_pkg_dir pkg_make_uninstall
	bs_notice "Package ${BUILD_LIST[@]} uninstall complete."
}

build_pkgs()
{
	if [ -z "$CONTINUE" ]; then
		bs_notice "Building package(s) \"${BUILD_LIST[@]}\"..."
		walk_pkg_dir -c pkg_make_uninstall pkg_make_distclean
		if [ $TARGET_PKGS = all ]; then
			rm /.first_config
		fi
	else
		bs_notice "Continue building package(s) \"${BUILD_LIST[@]}\"..."
	fi
	pushd /
	if declare -F configure_system > /dev/null && [ ! -f .first_config ]; then
		configure_system
		touch .first_config
	fi
	popd
	walk_pkg_dir pkg_unpack_patch pkg_make_install
	bs_notice "Package(s) \"${BUILD_LIST[@]}\" build complete."
}

install_pkgs()
{
	pushd $FS_ROOT
	if [ -z "$CONTINUE" ]; then
		bs_notice "Cleaning packages and ${FS_ROOT}"
		rm -rf * .[!.]*
	else
		bs_notice "Continue installing package(s) \"${BUILD_LIST[@]}\"..."
	fi
	if [ "$TARGET_PKGS" = all ]; then
		if declare -F configure_system > /dev/null && [ ! -f .first_config ]; then
			configure_system
			touch .first_config
		fi
	fi
	walk_pkg_dir pkg_unpack_patch pkg_make_install pkg_make_dest_install
	strip_rootfs
	popd
	bs_notice "Package(s) \"${BUILD_LIST[@]}\" install complete."
}

unpack_pkgs()
{
	if [ -z "$CONTINUE" ]; then
		bs_notice "Unpacking package(s) \"${BUILD_LIST[@]}\"..."
		walk_pkg_dir -c pkg_remove
	else
		bs_notice "Continue unpacking package(s) \"${BUILD_LIST[@]}\"..."
	fi
	walk_pkg_dir pkg_unpack_patch
	bs_notice "Package(s) \"${BUILD_LIST[@]}\" unpack complete."
}

strip_rootfs()
{
	local LOCDIR LOCALE
	OPATH=$PATH
	PATH=/tools/bin
	bs_notice "Stripping file system in ${PWD}..."
	find . -name "*.a" -or -name "*.la" | xargs rm -rvf
	EXE_LIST=$(find . -type f -executable -print0 | xargs -0 file -Ni 2> /dev/null || true)
	if [ -n "$EXE_LIST" ]; then
		echo "$EXE_LIST" | grep -F -e 'application/x-executable; charset=binary' \
			| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-all 2> /dev/null || true
		echo "$EXE_LIST" | grep -F -e 'application/x-sharedlib; charset=binary' \
			| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-debug 2> /dev/null || true
	fi
	rm -rvf ./${PREFIX}/share/{awk,doc,getopt,info,man,pkgconfig,readline,terminfo,vim} \
		./${PREFIX}/{doc,info,man,include} .first_config
	if [ "$LOCALES" != all ]; then
		pushd ./${PREFIX}/share/locale
		for LOCDIR in *; do
			if [ -d $LOCDIR ]; then
				for LOCALE in $LOCALES; do
					if [ $LOCDIR = $LOCALE ]; then
						continue 2
					fi
				done
				rm -rvf $LOCDIR
			fi
		done
		popd
	fi
	PATH=$OPATH
	bs_notice "RootFS stripped in $FS_ROOT"
}

tar_pkgs()
{
	install_pkgs
	pushd $FS_ROOT
	tar -Jcvf $GEN_DIR/$IMG_NAME.tar.xz .
	popd
	bs_notice "File $IMG_NAME.tar.xz generated successful"
}

iso_pkgs()
{
	tar_pkgs
	BUILD_LIST=(kernel-cd isolinux tools/xorriso)
	export CONTINUE=1
	install_pkgs

	pushd $FS_ROOT
	mkdir -p fake/{needwrite,ramdisk}
	mv etc/ var/ root/ home/ fake/needwrite/
	ln -s fake/needwrite/etc etc
	ln -s fake/needwrite/var var
	ln -s fake/needwrite/root root
	ln -s fake/needwrite/home home
	cat > etc/rc.d/init.d/create_ramdisk <<- "EOF"
	#!/bin/sh

	dev_ram=/dev/ram0
	dir_ramdisk=/fake/ramdisk
	dir_needwrite=/fake/needwrite

	source /etc/rc.d/init.d/functions

	case "$1" in
		start)
			echo -n "Creating ext2fs on $dev_ram ...              "
			/sbin/mke2fs -m 0 -i 1024 -q $dev_ram > /dev/null 2>&1
			evaluate_retval
			sleep 1
			echo -n "Mounting ramdisk on $dir_ramdisk ...         "
			mount -n $dev_ram $dir_ramdisk
			evaluate_retval
			sleep 1
			echo -n "Copying files to ramdisk ...                 "
			cp -dpR $dir_needwrite/* $dir_ramdisk > /dev/null 2>&1
			evaluate_retval
			sleep 1
			echo -n "Remount ramdisk to $dir_needwrite ...        "
			umount -n $dir_ramdisk > /dev/null 2>&1
			sleep 1
			mount -n $dev_ram $dir_needwrite
			sleep 1
			;;
		*)
			echo "Usage: $0 {start}"
			exit 1
			;;
	esac
	EOF
	chmod 0755 etc/rc.d/init.d/create_ramdisk
	ln -s ../init.d/create_ramdisk etc/rc.d/rcsysinit.d/S00create_ramdisk

	cat > /etc/fstab <<- "EOF"
	# Begin /etc/fstab for a bootable CD

	# file system  mount-point  type   options         dump  fsck
	#                                                        order
	#/dev/EDITME     /            EDITME  defaults        1     1
	#/dev/EDITME     swap         swap   pri=1           0     0
	proc           /proc        proc   defaults        0     0
	sysfs          /sys         sysfs  defaults        0     0
	devpts         /dev/pts     devpts gid=4,mode=620  0     0
	tmpfs          /dev/shm     tmpfs  defaults        0     0
	tmp            /tmp         tmpfs  defaults        0     0
	# End /etc/fstab
	EOF
	rm -f etc/rc.d/rcsysinit.d/S30checkfs
	sed -i -e 's/remount//g' etc/rc.d/init.d/mountfs
	mknod lib/udev/devices/loop0 b 7 0
	mknod dev/ram0 b 1 0
	dd if=/dev/zero of=boot/initrd bs=1024 count=8192
	mke2fs -m 0 -i 1024 -F boot/initrd
	mount -o loop boot/initrd mnt
	pushd mnt
	mkdir bin lib dev proc mnt
	mknod dev/ram0    b  1  0
	mknod dev/null    c  1  3
	mknod dev/zero    c  1  5
	mknod dev/console c  5  1
	mknod dev/ttyS0   c  4 64
	mknod dev/sr0     b 11  0
	mknod dev/sr1     b 11  1
	mknod dev/sda     b  8  0
	mknod dev/sdb     b  16  0
	mknod dev/sdc     b  32  0
	mknod dev/sdd     b  48  0
	mknod dev/hda     b  3  0
	mknod dev/hdb     b  3  64
	mknod dev/hdc     b  22  0
	mknod dev/hdd     b  22 64
	mknod dev/hde     b  33  0
	cp $FS_ROOT/bin/{bash,mount,grep,umount,echo} bin/
	cp $FS_ROOT/usr/bin/test bin/
	cp $FS_ROOT/usr/sbin/chroot bin/
	cp $FS_ROOT/sbin/pivot_root bin/
	ln -s bash bin/sh
	ln -s test bin/[
	cp $FS_ROOT/lib/{libncursesw.so.5,libdl.so.2,} lib/
	cp $FS_ROOT/lib/{libc.so.6,libreadline.so.6} lib/
	cp $FS_ROOT/lib/{libhistory.so.6,libblkid.so.1,libuuid.so.1} lib/
	if [ -f $FS_ROOT/lib/ld-linux.so.2 ] 
	then 
		cp -f $FS_ROOT/lib/ld-linux.so.2 lib/
	fi
	if [ -f $FS_ROOT/lib/ld.so.1 ] 
	then 
		cp -f $FS_ROOT/lib/ld.so.1 lib/
	fi
	cp $FS_ROOT/bin/{cat,sleep,mknod} bin/

	cat > $LFS/mnt/linuxrc <<- EOF
	#!/bin/sh
	#ID is the volume id / label of the LFS boot CD that will be looked for.
	ID=\"$IMG_NAME\"
	EOF
	cat >> $LFS/mnt/linuxrc <<- "EOF"
	TMP_MOUNT="/mnt"

	PATH="/bin:/sbin:/usr/bin:/usr/sbin"

	#this script searches for cdrom devices and then tries to find
	#the LFS boot CD in order to mount it as / (rootfs)

	#you need following programs:
	#- /bin/sh (e.g. bash)
	#- echo
	#- [ (which is linked to test)
	#- mount
	#- umount
	#- grep
	#- pivot_root
	#- chroot

	#you need following devices:
	#- /dev/hd*, /dev/sd*, /dev/sr* or /dev/cdrom*
	#- /dev/null

	#you need following directories:
	#- /proc
	#- $TMP_MOUNT

	CHECK_TYPE="try_mount"

	if [ ! -d "/proc/" ]; then
		mkdir /proc
	fi

	mount -n proc /proc -t proc

	#1. Create a list of possible cdrom devices.

	CDROM_LIST="/dev/sr0 /dev/sr1 /dev/cdrom /dev/hda /dev/hdb /dev/hdc /dev/hdd
	/dev/hde /dev/sda /dev/sdb"

	#2. now we try to find the LFS boot CD (we use ID as identification)

	LFS_CDROM_DEVICE=""
	echo "Using $CHECK_TYPE"
	for cdrom_device in $CDROM_LIST
	do
		echo -n "Checking $cdrom_device ... "

		if [ "$CHECK_TYPE" = "try_mount" ]; then
			mount -n -t iso9660 $cdrom_device $TMP_MOUNT > /dev/null 2>&1
			media_found=$?
		fi

		if [ $media_found -eq 0 ]; then

			echo -n "media found"
			if [ "$CHECK_TYPE" = "try_mount" ]; then
				[ -e "$TMP_MOUNT/$ID" ]
				media_lfs=$?
			fi

			if [ "$CHECK_TYPE" = "try_mount" ]; then
				umount -n $cdrom_device > /dev/null 2>&1
			fi

			if [ $media_lfs -eq 0 ]; then
				echo ", LFS boot CD found. Ready!"
				LFS_CDROM_DEVICE="$cdrom_device"
				break;
			else
				echo ", not LFS boot CD."
			fi

		else
			echo "no media "
		fi
	done

	#3. mount LFS CD as / (root fs)
	if [ "$LFS_CDROM_DEVICE" = "" ]; then

		echo "No LFS boot CD found!!!  You will have to fix this to continue"
		echo "do: mount -n -o ro -t iso9660 'your cd device' $TMP_MOUNT"
		echo "Then exit shell to continue"
		bash

	else

		echo "Booting from $LFS_CDROM_DEVICE ...                  "

		mount -n -o ro -t iso9660 $LFS_CDROM_DEVICE $TMP_MOUNT
	fi
	cd $TMP_MOUNT
	pivot_root . mnt
	umount -n /mnt/proc >/dev/null 2>&1
	exec chroot . sh -c 'umount -n /mnt >/dev/null 2>&1;\
		exec -a init.new /sbin/init 3'\
		<dev/console >dev/console 2>&1

	EOF
	chmod 0755 linuxrc
	popd
	umount $FS_ROOT/mnt
	gzip $FS_ROOT/boot/initrd
	mkisofs -R -l -L -D -b isolinux/isolinux.bin -c isolinux/boot.cat \
		-no-emul-boot -boot-load-size 4 -boot-info-table -V "$IMG_NAME" \
		. > $GEN_DIR/$IMG_NAME.iso
	popd
	bs_notice "Image $IMG_NAME.iso generated successful"
}

resolve_deps()
{
	return
}

parse_conf_var()
{
	if [ "$ARCH" = i686 ]; then
		set +h
		unset ARCH
	else
		set -h
		export ARCH
	fi
	: ${PREFIX:=/usr}
	export PREFIX
	if [ "$PREFIX" = /tools ]; then
		export BUILDSYS_LINK=tools PKG_CONFIG_PATH=/tools/lib/pkg-config
		unset BUILDSYS_HOST BUILDSYS_BUILD CROSS_MAKEOPTS CC CXX LD AR AS RANLIB STRIP
	else
		case $SDKARCH in
			i?86 | x86*)
				export BUILDSYS_LINK=root
				;;
			arm)
				export BUILDSYS_LINK=tools BUILDSYS_HOST="arm-buildsys-linux-gnueabi" \
					BUILDSYS_BUILD="i686-pc-linux-gnu" PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
				export_cross_tools $BUILDSYS_HOST
				CROSS_MAKEOPTS="CC=$CC CXX=$CXX AR=$AR AS=$AS RANLIB=$RANLIB LD=$LD STRIP=$STRIP"
				if [ ! -x "/tools/bin/${BUILDSYS_HOST}-cc" ]; then
					ln -s "${BUILDSYS_HOST}-gcc" "/tools/bin/${BUILDSYS_HOST}-cc"
				fi

				;;
		esac
	fi
	export IMG_NAME="$(basename ${BUILD_CONF})-$(echo $TARGET_PKGS | tr -s [:blank:] | tr [:blank:] -)-$(date +%F-%X)"
}

print_help_and_exit()
{
	exec >&2
	echo -e "Usage:\n $(basename $0) [Options] Command PackageName ..."
	echo "Options:"
	echo " -c, --continue		Resume previous buildsys process"
	echo " -f FILE, --config FILE	Use FILE as build config"
	echo "			(default: build-${SDKARCH:-i686}.conf)"
	echo " -j N, --jobs N		Build with N jobs running concurrently"
	echo "			(default N = number of CPUs)"
	echo " -h, --help		Print this help"
	echo "Command:"
	echo " unpack			Unpack only, don't build the package"
	echo " build			Build only, don't make target rootfs"
	echo "			(This is default if no Command specified)"
	echo " install			Install packages to rootfs"
	echo " gentar		Generate root filesystem tarball"
	echo " geniso		Generate root filesystem installation cd"
	echo " clean			Clean packages"
	echo " distclean		Dist clean package build directories and rootfs"
	echo " uninstall		Uninstall package from root directory in SDE"
	echo "PackageName:"
	echo " \"all\"			Build all packages specified in config file"
	echo "			(default all for empty PackageName)"
	echo " \"package name\"		Single or multiple package names overriding config file"
	exit
}

main()
{
	echo "Executing \"$0 $OPTS_ORIG\" with ${BUILD_CONF} at ${START_TIME}"

	parse_conf_var
	resolve_deps

	if [ -r /proc/cpuinfo ]; then
		: ${JOBS:="-j $(grep -F processor /proc/cpuinfo | wc -l)"}
	fi
	export MAKEFLAGS+=" $JOBS"

	cd "$DEV_ROOT"
	${ACTION:-build_pkgs}
}

GETOPTS=$(getopt -o cf:j:h --long continue,config:,jobs:,help -n "$0" -- "$@")
[ $? != 0 ] && print_help_and_exit

eval set -- "$GETOPTS"
while true; do
	case "$1" in
		-c|--continue)
			CONTINUE=1; shift
			;;
		-f|--config)
			BUILD_CONF="$2"
			if [ ! -f "$BUILD_CONF" ]; then
				BUILD_CONF="$INCDIR/${BUILD_CONF##*/}"
			fi
			if [ ! -f "$BUILD_CONF" ]; then
				bs_error "File \"$2\" not found"
				exit 1
			fi
			shift 2
			;;
		-j|--jobs)
			JOBS="$1 $2"
			shift 2
			;;
		-h|--help)
			print_help_and_exit
			;;
		--)
			shift ; break
			;;
		*)
			print_help_and_exit
			;;
	esac
done

if [ ! -d "$INCDIR" ]; then
	bs_error "Directory \"$INCDIR\" for global configuration not found"
fi

set -a
source ${BUILD_CONF:="$INCDIR/build-${SDKARCH}.conf"}
set +a

case "$1" in
	clean)
		ACTION=clean_pkgs; shift
		;;
	distclean)
		ACTION=distclean_pkgs; shift
		;;
	uninstall)
		ACTION=uninstall_pkgs; shift
		;;
	unpack)
		ACTION=unpack_pkgs; shift
		;;
	build)
		ACTION=build_pkgs; shift
		;;
	install)
		ACTION=install_pkgs; shift
		;;
	gentar)
		ACTION=tar_pkgs; shift
		;;
	geniso)
		ACTION=iso_pkgs; shift
		;;
	help)
		print_help_and_exit
		;;
esac

TARGET_PKGS="$@"
: ${TARGET_PKGS:=all}
if [ "$TARGET_PKGS" != all ]; then
	BUILD_LIST=("$TARGET_PKGS")
elif [ "${#BUILD_LIST[@]}" = 0 ]; then
	bs_error "No package to build. Please define BUILD_LIST in ${BUILD_CONF}"
fi

trap quit ERR

main $@ 2>&1 | tee "$DEV_ROOT/LOG/$(basename $BUILD_CONF)-$START_TIME.log"
