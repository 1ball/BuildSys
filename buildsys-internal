#!/tools/bin/bash

set -eET

START_TIME=$(date +%F-%X)
OPTS_ORIG="$@"
: ${DEV_ROOT:=/root}
export DEV_ROOT SDKARCH BUILD_DIR=$DEV_ROOT/BUILD SPECS=$DEV_ROOT/SPECS \
	PKG_POOL=$DEV_ROOT/POOL FS_ROOT=$DEV_ROOT/ROOT INCDIR=$DEV_ROOT/INC GEN_DIR=$DEV_ROOT/GEN

bs_error()
{
	echo -e "!!!!!!!! Error: $@ !!!!!!!!!!" >&2
	return 1
}

bs_notice()
{
	echo -e ">>>>>>>>> $@ <<<<<<<<<<"
}

quit()
{
	bs_error "buildsys process interrupted..."
	exit 1
}

unpack()
{
	local DEST='.'
	if [ -n "$2" ]; then
		DEST="$2"
	fi
	case "$1" in
		*.tar.gz | *.tar.bz2 | *.tar.xz | *.tgz | *.tbz | *.txz)
			tar -xf "$1" -C "$DEST"
			;;
		*.zip)
			unzip "$1" -d "$DEST"
			;;
		*)
			bs_error "Unknown package format for \"$1\""
			;;
	esac
	return 0
}

guess_pkg_info()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$PKG_FILE_NAME" in
			*.tar.gz | *.tar.bz2 | *.tar.xz)
				SUFFIX="tar.$SUFFIX"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%.$SUFFIX}"
		PKG_NAME="${PKG_NAME%-*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$SRC_DIR" ]; then
		SRC_DIR="$PKG_DIR/${PKG_NAME}-${VERSION}"
	else
		SRC_DIR="$PKG_DIR/${SRC_DIR}"
	fi
}

get_file()
{
	local SOURCE="$1" DEST="$2" FILE=
	local SOURCE_FILE="${SOURCE##*/}"
	if [ -f "$DEST"/"$SOURCE_FILE" ]; then
		bs_notice "File \"$SOURCE_FILE\" already exists in \"$DEST\", skip getting"
		return
	fi
	case "$SOURCE" in
		http://* | ftp://*)
			bs_notice "Downloading ${SOURCE}"
			wget -c -O "$DEST/${SOURCE_FILE}.partial" "$SOURCE"
			mv -v "$DEST"/${SOURCE_FILE}.partial "$DEST"/$SOURCE_FILE
			;;
		*)
			for FILE in "$SOURCE" "$SPECS/$PKG/$SOURCE" ""; do
				if [ -f "$FILE" ]; then
					ln -vsf "$FILE" "$DEST" || cp -v "$FILE" "$DEST"
					break
				fi
			done
			if [ -z "$FILE" ]; then
				bs_error "File \"$SOURCE\" not found"
			fi
			;;
	esac
}

precede_conf_opts()
{
	local ARG CONFIGURE
	case "$PKG_NAME" in
		vim)
			CONFIGURE=src/auto/configure
			;;
		cmake)
			CONFIGURE=bootstrap
			;;
		*)
			CONFIGURE=configure
			;;
	esac
	for ARG in $@; do
		if ! grep -F -q -e "${ARG%=*}" $CONFIGURE; then
			bs_notice "${PKG}'s configure does not support ${ARG%=*} directive"
		else
			CONFIGFLAGS="$ARG $CONFIGFLAGS"
		fi
	done
}

export_cross_tools()
{
	local TOOL
	for TOOL in CC AR AS RANLIB LD STRIP; do
		LOWERCASE=$(echo $TOOL | tr '[:upper:]' '[:lower:]')
		export eval $TOOL=${1}-${LOWERCASE}
	done
	export CXX="${1}-g++"
}

parse_conf_var()
{
	if [ "$SDKARCH" = i686 ]; then
		set +h
		unset ARCH
	else
		set -h
		export ARCH=$SDKARCH
		source /tools/installed_tools
	fi
	: ${PREFIX:=/usr}
	export PREFIX
	if [ "$PREFIX" = /tools ]; then
		export BUILDSYS_LINK=tools PKG_CONFIG_PATH=/tools/lib/pkg-config
		unset BUILDSYS_HOST BUILDSYS_BUILD CROSS_MAKEOPTS CC CXX LD AR AS RANLIB STRIP
	else
		case $SDKARCH in
			i?86 | x86*)
				export BUILDSYS_LINK=root
				;;
			arm)
				export BUILDSYS_LINK=tools BUILDSYS_HOST="arm-buildsys-linux-gnueabi" \
					BUILDSYS_BUILD="i686-pc-linux-gnu" PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
				export_cross_tools $BUILDSYS_HOST
				CROSS_MAKEOPTS="CC=$CC CXX=$CXX AR=$AR AS=$AS RANLIB=$RANLIB LD=$LD STRIP=$STRIP"
				if [ ! -x "/tools/bin/${BUILDSYS_HOST}-cc" ]; then
					ln -s "${BUILDSYS_HOST}-gcc" "/tools/bin/${BUILDSYS_HOST}-cc"
				fi
				;;
		esac
	fi
}

toolchain_link()
{
	OPATH="$PATH"
	PATH=/tools/bin
	pushd /tools/bin > /dev/null
	case "$1" in
		tools)
			ln -vf ld-old ld
			rm -vf `dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		root)
			ln -vf ld-new ld
			gcc -dumpspecs | sed -e 's@/tools@@g' \
				-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
				-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
				`dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		*)
			return 1
			;;
	esac
	popd > /dev/null
	PATH="$OPATH"
}

walk_pkg_dir()
{
	local SETOPTS='-eET'
	OPTIND=1
	while getopts "a:c" FLAG
	do
		case "$FLAG" in
			c)
				SETOPTS=''
				;;
			a)
				ACTS="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND - 1))

	for PKG in ${@}; do
		export PKG
		(
		local SPECFOUND=0
		set -a $SETOPTS
		PKG_DIR="${BUILD_DIR}/${PKG}"
		SPEC_DIR="$SPECS/$PKG"
		MAKEDIR="$PKG_DIR/build"
		if [ $(dirname $PKG) != . ]; then
			source $INCDIR/$(dirname $PKG)
			parse_conf_var
			PKG=$(basename $PKG)
		fi
		for SPECFILE in "${SPECS}/${PKG}/spec" "${SPECS}/${PKG}/${SPEC_NAME}"; do
			if [ -f $SPECFILE ]; then
				bs_notice "Reading $SPECFILE"
				source $SPECFILE
				: $((SPECFOUND |= 1))
			fi
		done
		if [ $SPECFOUND = 0 ]; then
			bs_error "${PKG}'s spec not found"
		fi
		[ "$PREFIX" = /tools ] && BUILDSYS_LINK=tools
		toolchain_link $BUILDSYS_LINK
		[ -n "$PKG_LOCATION" ] && guess_pkg_info "$PKG_LOCATION"
		mkdir -p "$PKG_DIR"
		pushd "$PKG_DIR"
		for ACT in $ACTS; do
			if [ -n "$SETOPTS" ]; then
				$ACT
			else
				$ACT || bs_notice "Ignoring errors"; continue
			fi
		done
		popd
		)
	done
}

pkg_unpack_patch()
{
	if [ ! -f .unpacked ] && [ ! -d "${SRC_DIR}" ]; then
		if [ -z "$PKG_LOCATION" ]; then
			bs_error "No source file defined for \"$PKG\""
		fi
		if [ -d "$PKG_LOCATION" ]; then
			ln -sv "$PKG_LOCATION" "$PKG_DIR"
		else
			get_file "$PKG_LOCATION" "$PKG_POOL"
			bs_notice "Unpacking file ${PKG_FILE_NAME}"
			unpack "${PKG_POOL}/${PKG_FILE_NAME}"
		fi
		for ADDITION in ${ADDITIONS[@]}; do
			get_file "$ADDITION" "$PKG_POOL"
			bs_notice "Unpacking file ${PKG_FILE_NAME}"
			unpack "$PKG_POOL/${ADDITION##*/}" "$SRC_DIR"
		done
		touch .unpacked
	fi
	if [ ! -f .patched ]; then
		pushd "$SRC_DIR"
		for PATCH in ${PATCHES[@]}; do
			get_file "$PATCH" "$PKG_POOL"
			patch --verbose -Np1 < $PKG_POOL/${PATCH##*/}
		done
		# Execute any script or binary with env variables exported for it
		# pre-build can be used to do patching job
		# Only bash and perl supported for scripting as of now
		[ -x ${SPECS}/${PKG}/pre-build ] && ${SPECS}/${PKG}/pre-build
		popd
		touch .patched
	fi
}

pkg_make_install()
{
	if [ ! -f .built ]; then
		pushd "$SRC_DIR"
		bs_notice "Building package ${PKG} in $SRC_DIR"
		if [ -x ${SPECS}/${PKG}/build ]; then
			${SPECS}/${PKG}/build
			ln -vs "$SRC_DIR" "$MAKEDIR"
		else
			if [ -r Makefile ] && [ ! -x configure ]; then
				MAKEFLAGS="PREFIX=$PREFIX prefix=$PREFIX $MAKEFLAGS"
				bs_notice "Executing make with $MAKEFLAGS" "$CROSS_MAKEOPTS"
				make $MAKEFLAGS $CROSS_MAKEOPTS
				make $MAKEFLAGS $CROSS_MAKEOPTS ${MAKE_TARGETS:-install}
				ln -vfs "$SRC_DIR" "$MAKEDIR"
			elif [ -x configure ]; then
				if [ ! -f ${PKG_DIR}/.configured ]; then
					precede_conf_opts "--prefix=$PREFIX"
					if [ -n "$BUILDSYS_BUILD" ] && [ -n "$BUILDSYS_HOST" ]; then
						precede_conf_opts "--build=$BUILDSYS_BUILD" "--host=$BUILDSYS_HOST"
					fi
					mkdir -p $MAKEDIR
					pushd $MAKEDIR
					bs_notice "Executing configure $CONFIGFLAGS"
					$SRC_DIR/configure ${CONFIGFLAGS}
					popd
					touch ${PKG_DIR}/.configured
				fi
				cd $MAKEDIR
				bs_notice "Executing make $MAKEFLAGS"
				make $MAKEFLAGS
				make $MAKEFLAGS ${MAKE_TARGETS:-install}
			elif [ -r ${PKG_NAME}.pro ]; then
				qmake
				make
				ln -vs "$SRC_DIR" "$MAKEDIR"
			else
				bs_error "Don't know how to build package $PKG."
			fi
		fi
		popd
		touch .built
	fi
	if [ ! -f .done ]; then
		# post-install can be used to fix installation problems
		if [ -x ${SPECS}/${PKG}/post-install ]; then
			pushd /
			${SPECS}/${PKG}/post-install
			popd
		fi
		touch .done
	else
		bs_notice "${PKG} has already been built. Skip."
		return
	fi
}

pkg_make_clean()
{
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	cd $MAKEDIR
	if ! grep -q '^clean:' Makefile; then
		bs_error "\"${PKG_NAME}\" does not support make clean"
	fi
	bs_notice "Cleaing \"$PKG\"..."
	make clean
	cd $PKG_DIR
	rm -f .done .built
}

pkg_make_distclean()
{
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	cd $MAKEDIR
	bs_notice "Dist cleaing \"$PKG\"..."
	if grep -q '^distclean:' Makefile; then
		make distclean
	elif grep -q '^clean:' Makefile; then
		make clean
	else
		bs_error "\"${PKG_NAME}\" does not support make clean or distclean"
	fi
	cd $PKG_DIR
	rm -f .done .built .configured
}

pkg_make_uninstall()
{
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	cd $MAKEDIR
	bs_notice "Uninstalling \"$PKG\"..."
	case $PKG_NAME in
		linux)
			;;
		*glibc)
			;;
		*)
			if ! grep -q '^uninstall' Makefile; then
				bs_error "Error: \"${PKG_NAME}\" does not support make uninstall"
			fi
			make DESTDIR=$FS_ROOT uninstall
			;;
	esac
	rm -f $PKG_DIR/.installed
}

pkg_make_dest_install()
{
	local FAKEROOT DESTVAR MAKEFILE=Makefile
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	if [ -f $PKG_DIR/.installed ]; then
		bs_notice "$PKG has already been installed, skipping..."
		return
	fi
	if [ "$TARGET_INSTALL" = n ]; then
		bs_notice "Package \"$PKG\" is not required to be installed on target."
		return
	fi
	bs_notice "Installing \"$PKG\" into ${FS_ROOT}..."
	cd $MAKEDIR
	case $PKG_NAME in
		*glibc)
			MAKEFILE='config.make'
			;;
		vim | sysvinit)
			MAKEFILE='src/Makefile'
			;;
		e2fsprogs)
			MAKEFILE='misc/Makefile'
			;;
	esac
	for DESTVAR in DESTDIR PREFIX ROOT ""; do
		if [ -z "$DESTVAR" ]; then
			break
		elif fgrep -q -w "$DESTVAR" $MAKEFILE; then
			if [ $DESTVAR = PREFIX ]; then
				FAKEROOT=${FS_ROOT}${PREFIX}
			else
				FAKEROOT=${FS_ROOT}
			fi
			bs_notice "Executing make $DESTVAR=${FAKEROOT} install"
			make $DESTVAR=${FAKEROOT} install
			break
		fi
	done
	# post-install can be used to fix target installation problems
	if [ -x ${SPECS}/${PKG}/post-install ]; then
		MAKEDIR="$PWD"
		pushd "$FS_ROOT"
		${SPECS}/${PKG}/post-install
		popd
	fi
	touch $PKG_DIR/.installed
}

pkg_remove()
{
	if [ -r "$PKG_POOL/$PKG_FILE_NAME" ] || [ -n "$PKG_LOCATION" ]; then
		cd $BUILD_DIR
		bs_notice "Removing $PKG_DIR"
		rm -rf "$PKG_DIR"
	elif [ -d "$MAKEDIR" ]; then
		pkg_make_distclean
	fi
}

clean_pkgs()
{
	walk_pkg_dir -a pkg_make_clean ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} clean complete."
}

distclean_pkgs()
{
	walk_pkg_dir -c -a pkg_make_distclean ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} dist clean complete."
}

uninstall_pkgs()
{
	bs_notice "${PKG_LIST[@]} are going to be uninstalled."
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_pkg_dir -c -a pkg_make_uninstall ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} uninstall complete."
}

build_pkgs()
{
	bs_notice "Building packages:"
	echo '========================================='
	printf "%s\n" "${PKG_LIST[@]}"
	echo '========================================='
	echo
	BUILD_LIST="$(resolve_deps ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	BUILD_LIST=(${BUILD_LIST#*,})
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be built after resolving dependencies:"
	echo '========================================='
	printf "%s\n" "${BUILD_LIST[@]}"
	echo '========================================='
	echo

	if [ -z "$CONTINUE" ]; then
		bs_notice "Building package(s) \"${PKG_LIST[@]}\"..."
		walk_pkg_dir -c -a "pkg_remove" ${BUILD_LIST[@]}
		if [ $TARGET_PKGS = all ]; then
			rm -vf /.first_config
		fi
	else
		bs_notice "Continue building package(s) \"${PKG_LIST[@]}\"..."
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]} ${BUILD_LIST[@]}
	bs_notice "Package(s) \"${PKG_LIST[@]}\" build complete."
}

install_pkgs()
{
	bs_notice "Installing packages:"
	echo '========================================='
	printf "%s\n" "${PKG_LIST[@]}"
	echo '========================================='
	echo
	BUILD_LIST="$(resolve_deps ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	BUILD_LIST=(${BUILD_LIST#*,})
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be built after resolving dependencies:"
	echo '========================================='
	printf "%s\n" "${BUILD_LIST[@]}"
	echo '========================================='
	echo

	pushd $FS_ROOT
	if [ -z "$CONTINUE" ]; then
		walk_pkg_dir -c -a pkg_make_uninstall ${BUILD_LIST[@]}
		bs_notice "Cleaning packages and ${FS_ROOT}"
		rm -rf * .[!.]*
	else
		bs_notice "Continue installing package(s) \"${PKG_LIST[@]}\"..."
	fi

	if [ "$TARGET_PKGS" = all ]; then
		if declare -F configure_system > /dev/null && [ ! -f .first_config ]; then
			configure_system
			touch .first_config
		fi
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]} ${BUILD_LIST[@]}
	walk_pkg_dir -a pkg_make_dest_install ${PKG_LIST[@]}
	strip_rootfs
	popd
	bs_notice "Package(s) \"${PKG_LIST[@]}\" install complete."
}

unpack_pkgs()
{
	if [ -z "$CONTINUE" ]; then
		bs_notice "Unpacking package(s) \"${PKG_LIST[@]}\"..."
		walk_pkg_dir -c -a pkg_remove ${PKG_LIST[@]}
	else
		bs_notice "Continue unpacking package(s) \"${PKG_LIST[@]}\"..."
	fi
	walk_pkg_dir -a pkg_unpack_patch ${PKG_LIST[@]}
	bs_notice "Package(s) \"${PKG_LIST[@]}\" unpack complete."
}

strip_rootfs()
{
	local LOCDIR LOCALE
	OPATH=$PATH
	PATH=/tools/bin
	bs_notice "Stripping file system in ${PWD}..."
	find . -name "*.a" -or -name "*.la" | xargs rm -rvf
	EXE_LIST=$(find . -type f -executable -print0 | xargs -0 file -Ni 2> /dev/null || true)
	if [ -n "$EXE_LIST" ]; then
		echo "$EXE_LIST" | grep -F -e 'application/x-executable; charset=binary' \
			| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-all 2> /dev/null || true
		echo "$EXE_LIST" | grep -F -e 'application/x-sharedlib; charset=binary' \
			| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-debug 2> /dev/null || true
	fi
	rm -rvf ./${PREFIX}/share/{awk,doc,getopt,info,man,pkgconfig,readline,vim} \
		./${PREFIX}/{doc,info,man,include} .first_config
	if [ "$LOCALES" != all ] && [ -d ./${PREFIX}/share/locale ]; then
		pushd ./${PREFIX}/share/locale
		for LOCDIR in *; do
			if [ -d $LOCDIR ]; then
				for LOCALE in $LOCALES; do
					if [ $LOCDIR = $LOCALE ]; then
						continue 2
					fi
				done
				rm -rvf $LOCDIR
			fi
		done
		popd
	fi
	PATH=$OPATH
	bs_notice "RootFS stripped in $FS_ROOT"
}

tar_pkgs()
{
	install_pkgs
	pushd $FS_ROOT
	tar -Jcvf $GEN_DIR/$IMG_NAME.tar.xz .
	popd
	bs_notice "File $IMG_NAME.tar.xz generated successfully"
}

ext4_pkgs()
{
	local FS_SIZE
	IMG_EXT4=$GEN_DIR/$IMG_NAME.ext4

	pushd $FS_ROOT
	if [ -z "$CONTINUE" ]; then
		walk_pkg_dir -c -a pkg_make_uninstall ${PKG_LIST[@]}
		if [ "$TARGET_PKGS" = all ]; then
			bs_notice "Cleaning packages and ${FS_ROOT}"
			rm -rf * .[!.]*
		fi
	else
		bs_notice "Continue installing package(s) \"${PKG_LIST[@]}\"..."
	fi

	BUILD_LIST="$(resolve_deps ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	INSTALL_LIST=(${BUILD_LIST#*,})
	bs_notice "Packages to be installed after resolving dependencies:"
	echo '========================================='
	printf "%s\n" " ${INSTALL_LIST[@]}"
	echo '========================================='

	if [ "$TARGET_PKGS" = all ]; then
		if declare -F configure_system > /dev/null && [ ! -f .first_config ]; then
			configure_system
			touch .first_config
		fi
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]}
	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install pkg_make_dest_install" ${INSTALL_LIST[@]}
	strip_rootfs

	FS_SIZE=$(du -sb . | cut -f1)
	dd if=/dev/zero of=$IMG_EXT4 bs=1 count=1 seek=$((FS_SIZE + FS_SIZE/5))
	mkfs.ext4 -F $IMG_EXT4
	mkdir -pv /tmp/$$
	mount -o loop -t ext4 $IMG_EXT4 /tmp/$$
	bs_notice "Copying files into ext4 file system"
	cp -a . /tmp/$$
	umount /tmp/$$
	rmdir -v /tmp/$$
	e2fsck -yf $IMG_EXT4
	resize2fs -M $IMG_EXT4
	popd
	bs_notice "File $IMG_NAME.ext4 generated successfully"
}

iso_pkgs()
{
	ISO_ROOT=$DEV_ROOT/ISOROOT
	install_pkgs
	bs_notice "Cleaning $ISO_ROOT"
	rm -rf $ISO_ROOT
	bs_notice "Copying $FS_ROOT to $ISO_ROOT"
	cp -a $FS_ROOT $ISO_ROOT
	FS_ROOT=$ISO_ROOT
	CONTINUE=1
	PKG_LIST=(kernel-cd isolinux)
	unset TARGET_PKGS
	install_pkgs

	pushd $ISO_ROOT
	cat > etc/rc.d/init.d/create_ramdisk <<- "EOF"
	#!/bin/sh
	# SET UP SOME VARIABLES FOR DEVICES AND DIRECTORIES
	dev_ram=/dev/ram1
	dev_ram2=/dev/ram2
	dir_ramdisk=/fake/ramdisk
	dir_needwrite=/fake/needwrite
	# SOURCE THE FUNCTIONS FILE
	source /etc/rc.d/init.d/functions
	case "$1" in
		start)
			# CREATE THE RAM DISK
			echo "Creating ext2fs on $dev_ram..."
			/sbin/mke2fs -m 0 -i 1024 -q $dev_ram > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# MOUNT THE RAM DISK
			echo "Mounting ramdisk on $dir_ramdisk..."
			mount -n $dev_ram $dir_ramdisk -t ext2
			evaluate_retval
			sleep 1
			# COPY FILES TO THE RAM DISK
			echo "Copying files to ramdisk..."
			cp -a $dir_needwrite/* $dir_ramdisk > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# CREATE SECOND RAMDISK
			echo "Creating second ramdisk"
			/sbin/mke2fs -m 0 -i 1024 -q $dev_ram2 > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# MOUNT SECOND RAMDISK
			echo "Mounting second ram disk"
			mount -n $dev_ram2 $dir_needwrite -t ext2
			evaluate_retval
			sleep 1
			# COPY FILES TO THE SECOND RAMDISK
			echo "Copying files to the second ram disk"
			cp -a $dir_ramdisk/* $dir_needwrite
			evaluate_retval
			sleep 1
			# UNMOUNT THE FIRST RAMDISK
			echo "Unmounting and clearing first ram disk"
			umount -n $dir_ramdisk > /dev/null 2>&1
			blockdev --flushbufs /dev/ram1
			evaluate_retval
			sleep 1
			;;
		*)
			echo "Usage: $0 {start}"
			exit 1
			;;
	esac
	EOF

	chmod -v 0755 etc/rc.d/init.d/create_ramdisk
	ln -vfs ../init.d/create_ramdisk etc/rc.d/rcS.d/S00create_ramdisk

	cat > etc/fstab <<- "EOF"
	# Begin /etc/fstab for a bootable CD

	# file system  mount-point  type   options         dump  fsck
	#                                                        order
	CDROM     /            iso9660  ro        1     1
	#/dev/EDITME     swap         swap   pri=1           0     0
	proc           /proc        proc   nosuid,noexec,nodev        0     0
	sysfs          /sys         sysfs  nosuid,noexec,nodev        0     0
	devtmpfs          /dev         devtmpfs  mode=0755,nosuid        0     0
	devpts         /dev/pts     devpts gid=4,mode=620  0     0
	tmp            /tmp         tmpfs  defaults        0     0
	tmpfs            /run         tmpfs  rw,noexec,nosuid,size=10%,mode=0755        0     0
	/dev/ram2		/fake/needwrite		ext2 defaults 	0 	0
	# End /etc/fstab
	EOF

	rm -vf etc/rc.d/rcS.d/S30checkfs
	#rm -vf etc/rc.d/rcS.d/S40mountfs
	sed -i -e '/remount/d' -e '48a\
		mount -f /fake/needwrite || failed=1
	' etc/rc.d/init.d/mountfs
	#sed -i -e 's/remount,rw/remount,ro/g' etc/rc.d/init.d/mountfs
	mknod lib/udev/devices/loop0 b 7 0
	mkdir -pv dev
	local i
	for i in 1 2; do
		mknod dev/ram$i b 1 $i
	done
	mknod dev/null    c  1  3
	mknod dev/zero    c  1  5
	mknod dev/console c  5  1
	mknod dev/ttyS0   c  4 64

	rm -rvf fake
	mkdir -vp fake/{needwrite,ramdisk}
	mv -vf etc/ var/ root/ home/ fake/needwrite/
	ln -vfs fake/needwrite/etc etc
	ln -vfs fake/needwrite/var var
	ln -vfs fake/needwrite/root root
	ln -vfs fake/needwrite/home home

	dd if=/dev/zero of=boot/initrd bs=1k count=1 seek=8191
	mke2fs -v -m 0 -i 1024 -F boot/initrd
	mount -vo loop boot/initrd mnt
	pushd mnt
	mkdir -vp bin lib dev proc mnt
	mknod dev/ram0    b  1  0
	mknod dev/null    c  1  3
	mknod dev/zero    c  1  5
	mknod dev/console c  5  1
	mknod dev/ttyS0   c  4 64
	mknod dev/sr0     b 11  0
	mknod dev/sr1     b 11  1
	mknod dev/sda     b  8  0
	mknod dev/sdb     b  16  0
	mknod dev/sdc     b  32  0
	mknod dev/sdd     b  48  0
	mknod dev/hda     b  3  0
	mknod dev/hdb     b  3  64
	mknod dev/hdc     b  22  0
	mknod dev/hdd     b  22 64
	mknod dev/hde     b  33  0
	cp -v $ISO_ROOT/bin/{bash,mount,grep,umount,echo,dd} bin/
	cp -v $ISO_ROOT/usr/bin/test bin/
	cp -v $ISO_ROOT/usr/sbin/chroot bin/
	cp -v $ISO_ROOT/sbin/pivot_root bin/
	ln -vfs bash bin/sh
	ln -vfs test bin/[
	cp -v $ISO_ROOT/lib/{libncursesw.so.5,libdl.so.2} lib/
	cp -v $ISO_ROOT/lib/{libc.so.6,libreadline.so.6} lib/
	cp -v $ISO_ROOT/lib/{libhistory.so.6,libblkid.so.1,libuuid.so.1} lib/
	cp -v $ISO_ROOT/lib/{libpthread.so.0,librt.so.1} lib/
	if [ -f $ISO_ROOT/lib/ld-linux.so.2 ] 
	then 
		cp -v -f $ISO_ROOT/lib/ld-linux.so.2 lib/
	fi
	if [ -f $ISO_ROOT/lib/ld.so.1 ] 
	then 
		cp -v -f $ISO_ROOT/lib/ld.so.1 lib/
	fi
	cp -v $ISO_ROOT/bin/{cat,sleep,mknod} bin/

	cat > linuxrc <<- EOF
	#!/bin/sh
	#ID is the volume id / label of the boot CD that will be looked for.
	ID="$IMG_NAME"
	EOF

	cat >> linuxrc <<- "EOF"
	TMP_MOUNT="/mnt"

	PATH="/bin:/sbin:/usr/bin:/usr/sbin"

	#this script searches for cdrom devices and then tries to find
	#the boot CD in order to mount it as / (rootfs)

	#you need following programs:
	#- /bin/sh (e.g. bash)
	#- echo
	#- [ (which is linked to test)
	#- mount
	#- umount
	#- grep
	#- pivot_root
	#- chroot

	#you need following devices:
	#- /dev/hd*, /dev/sd*, /dev/sr* or /dev/cdrom*
	#- /dev/null

	#you need following directories:
	#- /proc
	#- $TMP_MOUNT

	CHECK_TYPE="try_mount"

	if [ ! -d "/proc/" ]; then
		mkdir /proc
	fi

	mount -n proc /proc -t proc

	#1. Create a list of possible cdrom devices.

	CDROM_LIST="/dev/sr0 /dev/sr1 /dev/cdrom /dev/hda /dev/hdb /dev/hdc /dev/hdd /dev/hde /dev/sda /dev/sdb"

	#2. now we try to find the boot CD (we use ID as identification)

	CDROM_DEVICE=""
	echo "Using $CHECK_TYPE"
	for cdrom_device in $CDROM_LIST
	do
		echo -n "Checking $cdrom_device ... "

		if [ "$CHECK_TYPE" = "try_mount" ]; then
			mount -n -t iso9660 $cdrom_device $TMP_MOUNT > /dev/null 2>&1
			media_found=$?
		fi

		if [ $media_found -eq 0 ]; then

			echo -n "media found"
			if [ "$CHECK_TYPE" = "try_mount" ]; then
				[ "$(dd if=$cdrom_device bs=1 count=32 skip=32808 2> /dev/null)" = "$ID" ]
				buildsys_media=$?
			fi

			if [ "$CHECK_TYPE" = "try_mount" ]; then
				umount -n $cdrom_device > /dev/null 2>&1
			fi

			if [ $buildsys_media -eq 0 ]; then
				echo ", BuildSys generated boot CD found. Ready!"
				CDROM_DEVICE="$cdrom_device"
				break;
			else
				echo ", not BuildSys generated boot CD."
			fi

		else
			echo "no media "
		fi
	done

	#3. mount CD as / (root fs)
	if [ "$CDROM_DEVICE" = "" ]; then

		echo "No boot CD found!!!  You will have to fix this to continue"
		echo "do: mount -n -o ro -t iso9660 'your cd device' $TMP_MOUNT"
		echo "Then exit shell to continue"
		bash

	else

		echo "Booting from $CDROM_DEVICE ..."

		mount -n -o ro -t iso9660 $CDROM_DEVICE $TMP_MOUNT
	fi
	cd $TMP_MOUNT
	#sed -i -e "s/CDROM/$CDROM_DEVICE/g" ./etc/fstab
	pivot_root . mnt
	umount -n /mnt/proc
	exec chroot . sh -c 'umount -n /mnt >/dev/null 2>&1;\
		exec -a init.new /sbin/init 3'\
		<dev/console >dev/console 2>&1

	EOF
	chmod -v 0755 linuxrc
	popd
	while ! umount -v $ISO_ROOT/mnt; do
		sleep 1
	done
	gzip $ISO_ROOT/boot/initrd
	genisoimage -R -l -L -D -b isolinux/isolinux.bin -c isolinux/boot.cat \
		-no-emul-boot -boot-load-size 4 -boot-info-table -V "$IMG_NAME" \
		. > $GEN_DIR/$IMG_NAME.iso
	popd
	bs_notice "Image $IMG_NAME.iso generated successfully"
}

add_dep_pkgs()
{
	local PKG CONF_NAME PKG_DIR_NAME DEP= SPECFILE SPECFOUND=0
	for (( i = $#; i > 0; i-- )); do
		local -a PKGS=()
		for PKG_IN_LIST in ${PROCESSED_LIST[@]} ""; do
			if [ "${!i}" != "$PKG_IN_LIST" ]; then
				PKGS+=($PKG_IN_LIST)
			fi
		done
		PROCESSED_LIST=(${!i} ${PKGS[@]})
	done
	for (( i = $#; i > 0; i-- )); do
		local -a DEPS=()
		CONF_NAME=$(dirname ${!i})
		PKG_DIR_NAME=$(basename ${!i})
		for SPECFILE in "${SPECS}/${PKG_DIR_NAME}/spec" "${SPECS}/${PKG_DIR_NAME}/${SPEC_NAME}"; do
			if [ -f $SPECFILE ]; then
				source $SPECFILE
				: $((SPECFOUND |= 1))
			fi
		done
		if [ $SPECFOUND = 0 ]; then
			bs_error "${!i}'s spec not found"
		fi
		if [ ${#TOOL_DEPS[@]} != 0 ]; then
			add_tool_dep_pkgs ${TOOL_DEPS[@]}
		fi
		if [ ${#DEPS[@]} != 0 ]; then
			add_dep_pkgs ${DEPS[@]}
		fi
	done
}

add_tool_dep_pkgs()
{
	local PKG CONF_NAME PKG_DIR_NAME DEP SPECFILE SPECFOUND=0
	echo $LINENO INPUT: "${@}" >&2
	echo $LINENO TOOL_PROCESSED_LIST: "${TOOL_PROCESSED_LIST[@]}" >&2
	for (( i = $#; i > 0; i-- )); do
		local -a PKGS=()
		for PKG_IN_LIST in ${TOOL_PROCESSED_LIST[@]} ""; do
			if [ "${!i}" != "$PKG_IN_LIST" ]; then
				PKGS+=($PKG_IN_LIST)
			fi
		done
		TOOL_PROCESSED_LIST=(${!i} ${PKGS[@]})
	done
	for (( i = $#; i > 0; i-- )); do
		local -a DEPS=() TOOL_DEPS=()
		CONF_NAME=$(dirname ${!i})
		PKG_DIR_NAME=$(basename ${!i})
		for SPECFILE in "${SPECS}/${PKG_DIR_NAME}/spec" "${SPECS}/${PKG_DIR_NAME}/${SPEC_NAME}"; do
			if [ -f $SPECFILE ]; then
				source $SPECFILE
				: $((SPECFOUND |= 1))
			fi
		done
		if [ $SPECFOUND = 0 ]; then
			bs_error "${!i}'s spec not found"
		fi
#		echo $LINENO TOOL_DEPS: "${TOOL_DEPS[@]}" >&2
#		echo $LINENO DEPS: "${DEPS[@]}" >&2
		if [ ${#TOOL_DEPS[@]} != 0 ]; then
			add_tool_dep_pkgs ${TOOL_DEPS[@]}
		fi
		if [ ${#DEPS[@]} != 0 ]; then
			add_tool_dep_pkgs ${DEPS[@]}
		fi
	done
}

resolve_deps()
{
	local -a PROCESSED_LIST= TOOL_PROCESSED_LIST=(${BSE_TOOLS[@]})
	add_dep_pkgs $@
	case $SDKARCH in
		i?86|x86*)
			;;
		*)
			for (( i = 0; i < ${#TOOL_PROCESSED_LIST[@]}; i++ )); do
				TOOL_PROCESSED_LIST[i]="tools.conf/${TOOLS_LIST[i]#tools.conf/}"
			done
			;;
	esac
	echo "${TOOL_PROCESSED_LIST[@]},${PROCESSED_LIST[@]}"
}

print_help_and_exit()
{
	exec >&2
	echo -e "Usage:\n $(basename $0) [Options] Command PackageName ..."
	echo "Options:"
	echo " -c, --continue		Resume previous buildsys process"
	echo " -f FILE, --config FILE	Use FILE as build config"
	echo "			(default: build-${SDKARCH:-i686}.conf)"
	echo " -j N, --jobs N		Build with N jobs running concurrently"
	echo "			(default N = number of CPUs)"
	echo " -h, --help		Print this help"
	echo "Command:"
	echo " unpack			Unpack only, don't build the package"
	echo " build			Build only, don't make target rootfs"
	echo "			(This is default if no Command specified)"
	echo " install		Install packages to rootfs"
	echo " gentar			Generate root filesystem tarball"
	echo " genext4		Generate ext4 root filesystem"
	echo " geniso			Generate root filesystem installation cd"
	echo " clean			Clean packages"
	echo " distclean		Dist clean package build directories and rootfs"
	echo " uninstall		Uninstall package from root directory in SDE"
	echo "PackageName:"
	echo " \"all\"			Build all packages specified in config file"
	echo "			(default all for empty PackageName)"
	echo " \"package name\"		Single or multiple package names overriding config file"
	exit
}

main()
{
	echo "Executing \"$(basename $0) $OPTS_ORIG\" with ${BUILD_CONF} at ${START_TIME}"

	export IMG_NAME="$(basename ${BUILD_CONF})-$(echo $TARGET_PKGS | tr -s [:blank:] | tr [:blank:] -)-$(date +%Y%m%d%H%M)"

	parse_conf_var

	if [ -r /proc/cpuinfo ]; then
		: ${JOBS:="-j $(grep -F processor /proc/cpuinfo | wc -l)"}
	fi
	export MAKEFLAGS+=" $JOBS"

	pushd /
	if declare -F configure_system > /dev/null && [ ! -f .first_config ]; then
		configure_system
		touch .first_config
	fi
	popd

	cd "$DEV_ROOT"
	${ACTION:-build_pkgs}
}

GETOPTS=$(getopt -o cf:j:h --long continue,config:,jobs:,help -n "$0" -- "$@")
[ $? != 0 ] && print_help_and_exit

eval set -- "$GETOPTS"
while true; do
	case "$1" in
		-c|--continue)
			export CONTINUE=1; shift
			;;
		-f|--config)
			BUILD_CONF="$2"
			if [ ! -f "$BUILD_CONF" ]; then
				BUILD_CONF="$INCDIR/${BUILD_CONF##*/}"
			fi
			if [ ! -f "$BUILD_CONF" ]; then
				bs_error "File \"$2\" not found"
				exit 1
			fi
			shift 2
			;;
		-j|--jobs)
			JOBS="$1 $2"
			shift 2
			;;
		-h|--help)
			print_help_and_exit
			;;
		--)
			shift ; break
			;;
		*)
			print_help_and_exit
			;;
	esac
done

if [ ! -d "$INCDIR" ]; then
	bs_error "Directory \"$INCDIR\" for global configuration not found"
fi

set -a
source ${BUILD_CONF:="$INCDIR/build-${SDKARCH}.conf"}
set +a

case "$1" in
	clean)
		ACTION=clean_pkgs; shift
		;;
	distclean)
		ACTION=distclean_pkgs; shift
		;;
	uninstall)
		ACTION=uninstall_pkgs; shift
		;;
	unpack)
		ACTION=unpack_pkgs; shift
		;;
	build)
		ACTION=build_pkgs; shift
		;;
	install)
		ACTION=install_pkgs; shift
		;;
	gentar)
		ACTION=tar_pkgs; shift
		;;
	genext4)
		ACTION=ext4_pkgs; shift
		;;
	geniso)
		ACTION=iso_pkgs; shift
		;;
	help)
		print_help_and_exit
		;;
esac

TARGET_PKGS="$@"
: ${TARGET_PKGS:=all}
if [ "$TARGET_PKGS" != all ]; then
	PKG_LIST=("$TARGET_PKGS")
elif [ "${#PKG_LIST[@]}" = 0 ]; then
	bs_error "No package to build. Please define PKG_LIST in ${BUILD_CONF}"
fi

trap quit ERR

main $@ 2>&1 | tee "$DEV_ROOT/LOG/$(basename $BUILD_CONF)-$START_TIME.log"
