#!/tools/bin/bash

set -eET

START_TIME=$(date +%F-%X)
OPTS_ORIG="$@"
: ${DEV_ROOT:=/root}
SDKPATH=$PATH
export DEV_ROOT SDKARCH BUILD_DIR=$DEV_ROOT/BUILD SPECS=$DEV_ROOT/SPECS \
	PKG_POOL=$DEV_ROOT/POOL FSROOT=$DEV_ROOT/ROOT INCDIR=$DEV_ROOT/INC GEN_DIR=$DEV_ROOT/GEN

bs_error()
{
	echo -e "!!!!!!!! Error: $@ !!!!!!!!!!" >&2
	return 1
}

bs_notice()
{
	echo -e ">>>>>>>>> $@ <<<<<<<<<<"
}

quit()
{
	bs_error "buildsys process interrupted..."
	exit 1
}

unpack()
{
	local DEST='.' PROG
	if [ -n "$2" ]; then
		DEST="$2"
	fi
	case "$1" in
		*.tar.gz | *.tar.bz2 | *.tar.xz | *.tgz | *.tbz | *.txz)
			case "$1" in
				*gz)
					PROG=gzip
					;;
				*.bz2|*.tbz)
					PROG=bzip2
					;;
				*xz)
					PROG=xz
					;;
			esac
			echo tar --use-compress-program /tools/bin/$PROG -xf "$1" -C "$DEST"
			tar --use-compress-program /tools/bin/$PROG -xf "$1" -C "$DEST"
			;;
		*.zip)
			unzip "$1" -d "$DEST"
			;;
		*.src.rpm | *.SRC.RPM)
			DEST="$DEST/$(basename $SRC_DIR)"
			mkdir -pv $DEST
			pushd "$DEST"
			rpm2cpio "$1" | cpio -diumv
			popd
			;;
		*.txt)
			DEST="$DEST/$(basename $SRC_DIR)"
			mkdir -pv $DEST
			ln -svf "$1" "$DEST/"
			;;
		*)
			bs_error "Unknown package format for \"$1\""
			;;
	esac
	return 0
}

guess_pkg_info_from_location()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$PKG_FILE_NAME" in
			*.tar.gz | *.tar.bz2 | *.tar.xz)
				SUFFIX="tar.$SUFFIX"
				;;
			*.src.rpm | *.SRC.RPM)
				SUFFIX="${PKG_FILE_NAME: -7}"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		if [ "$SUFFIX" = src.rpm ]; then
			: ${RPM_RELEASE:=${VERSION##*-}}
			VERSION=${VERSION%-$RPM_RELEASE}
		fi
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%-${VERSION}*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$SRC_DIR" ]; then
		SRC_DIR="$PKG_DIR/${PKG_NAME}-${VERSION}"
	else
		SRC_DIR="$PKG_DIR/${SRC_DIR}"
	fi
	if [ -z "$MAKEDIR" ]; then
		MAKEDIR="$PKG_DIR/build-$PKG_NAME"
	else
		MAKEDIR="$PKG_DIR/$MAKEDIR"
	fi
	: ${RPM_SPEC:="$SRC_DIR/$PKG_NAME.spec"}
	case "$SUFFIX" in
		src.rpm|SRC.RPM)
			FAKEROOT="$PKG_DIR/files"
			: ${INSTALL_FILES:='*'}
			;;
		*)
			if [[ "${#INSTALL_FILES[@]}" = 0 ]]; then
				FAKEROOT=$FSROOT
			else
				FAKEROOT="$PKG_DIR/files"
			fi
			;;
	esac
}

get_file()
{
	local SOURCE="$1" DEST="$2" FILE=
	local SOURCE_FILE="${SOURCE##*/}"

	SOURCE_FILE="${SOURCE_FILE%\?*}"
	if [ -f "$DEST"/"$SOURCE_FILE" ]; then
		bs_notice "File \"$SOURCE_FILE\" already exists in \"$DEST\", skip getting"
		return
	fi
	case "$SOURCE" in
		http://* | ftp://*)
			bs_notice "Downloading ${SOURCE}"
			wget -c -O "$DEST/${SOURCE_FILE}.partial" "$SOURCE"
			mv -v "$DEST"/${SOURCE_FILE}.partial "$DEST"/$SOURCE_FILE
			;;
		*)
			for FILE in "$SOURCE" "$PKG_SPECDIR/$SOURCE" ""; do
				if [ -f "$FILE" ]; then
					ln -vsf "$FILE" "$DEST" || cp -v "$FILE" "$DEST"
					break
				fi
			done
			if [ -z "$FILE" ]; then
				bs_error "File \"$SOURCE\" not found"
			fi
			;;
	esac
}

precede_conf_opts()
{
	local ARG
	if [ -z "$CONFIGURE" ]; then
		case "$PKG_NAME" in
			vim)
				CONFIGURE=src/auto/configure
				;;
			cmake)
				CONFIGURE=bootstrap
				;;
			freetype)
				CONFIGURE=builds/unix/configure
				;;
			openssl)
				CONFIGURE=Configure
				;;
			*)
				CONFIGURE=configure
				;;
		esac
	fi
	for ARG in $@; do
		if ! in_list "$ARG" ${CONFIGFLAGS[@]}; then
			if ! grep -F -q -e "${ARG%=*}" $CONFIGURE; then
				bs_error "${PKG}'s configure does not support ${ARG%=*} directive"
			else
				CONFIGFLAGS=($ARG ${CONFIGFLAGS[@]})
			fi
		fi
	done
}

export_cross_tools()
{
	local TOOL
	for TOOL in CC AR AS RANLIB LD STRIP; do
		LOWERCASE=$(echo $TOOL | tr '[:upper:]' '[:lower:]')
		export eval $TOOL=${1}-${LOWERCASE}
	done
	export CXX="${1}-g++"
}

parse_conf_var()
{
	if [ "$SDKARCH" = i686 ]; then
		set +h
		PATH=$SDKPATH
		unset ARCH
	else
		export ARCH=$SDKARCH
	fi
	: ${PREFIX:=/usr}
	if [ "$PREFIX" = /tools ]; then
		export BUILDSYS_LINK=tools PKG_CONFIG_PATH=/tools/lib/pkg-config
		unset BUILDSYS_HOST BUILDSYS_BUILD CROSS_MAKEOPTS CC CXX LD AR AS RANLIB STRIP
	else
		export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
		case $SDKARCH in
			i?86 | x86*)
				export ${BUILDSYS_LINK:=root}
				;;
			arm)
				export BUILDSYS_LINK=tools BUILDSYS_HOST="arm-buildsys-linux-gnueabi" \
					BUILDSYS_BUILD="i686-pc-linux-gnu"
				export_cross_tools $BUILDSYS_HOST
				CROSS_MAKEOPTS="CC=$CC CXX=$CXX AR=$AR AS=$AS RANLIB=$RANLIB LD=$LD STRIP=$STRIP"
				if [ ! -x "/tools/bin/${BUILDSYS_HOST}-cc" ]; then
					ln -s "${BUILDSYS_HOST}-gcc" "/tools/bin/${BUILDSYS_HOST}-cc"
				fi
				;;
		esac
	fi
	export PATH PREFIX LAST_TOOLCHAIN_LINK=
}

toolchain_link()
{
	if [ -r /tmp/bs_toolchain_link ]; then
		source /tmp/bs_toolchain_link
		if [ "$TOOLCHAIN_LINK" = $1 ]; then
			return
		fi
	fi
	OPATH="$PATH"
	PATH=/tools/bin
	pushd /tools/bin > /dev/null
	case "$1" in
		tools)
			ln -vf ld-old ld
			rm -vf `dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		root)
			ln -vf ld-new ld
			gcc -dumpspecs | sed -e 's@/tools@@g' \
				-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
				-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
				`dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		*)
			return 1
			;;
	esac
	popd > /dev/null
	PATH="$OPATH"
	echo "TOOLCHAIN_LINK=$1" > /tmp/bs_toolchain_link
}

set_passwd()
{
	local USER="$1" PASS="$2"
	if [ -z "$PASS" ]; then
		chroot $FSROOT passwd -d $USER
	else
		{
			while true; do
				echo "$PASS"
			done
		} | chroot $FSROOT passwd $USER
	fi
}

makefile_of_pkg()
{
	case $1 in
		*glibc)
			echo -n 'config.make'
			;;
		vim | sysvinit)
			echo -n 'src/Makefile'
			;;
		e2fsprogs)
			echo -n 'Makefile misc/Makefile'
			;;
		nspr)
			echo -n 'config/Makefile'
			;;
		freetype)
			echo -n "$SRC_DIR/builds/unix/install.mk"
			;;
		*)
			echo -n 'Makefile'
			;;
	esac
}

make_fakeroot()
{
	local DEST="$FAKEROOT" DESTVAR PKG_NAME=${1} \
		MAKEFILE="$(makefile_of_pkg $1)" MAKE_TARGET MAKE_TARGETS
	local -i i
	shift
	if [ -x ${PKG_SPECDIR}/build ]; then
		return
	fi
	local -a MAKE_TARGETS=($@)
	case $PKG_NAME in
		linux)
			DESTVAR=INSTALL_MOD_PATH
			;;
		MesaLib|talloc)
			DESTVAR=DESTDIR
			;;
	esac
	for MAKE_TARGET in ${MAKE_TARGETS[@]}; do
		if ! grep -q "^$MAKE_TARGET" $MAKEFILE; then
			bs_notice "\"${PKG_NAME}\" does not support make $MAKE_TARGET"
#			return 1
		fi
	done
	if [ -z "$DESTVAR" ]; then
		for DESTVAR in DESTDIR PREFIX ROOT prefix ""; do
			if fgrep -q -w "$DESTVAR" $MAKEFILE; then
				break
			fi
		done
	fi
	case "$DESTVAR" in
		'')
			bs_error "Don't know how to install $PKG"
			;;
		PREFIX|prefix)
			DEST+=${PREFIX}
			;;
	esac
	for (( i = 0; i < ${#MAKE_TARGETS[@]}; i++ )); do
		if [[ -z "${MAKE_TARGETS[$i]}" || ${MAKE_TARGETS[$i]} = all ]]; then
			continue
		fi
		bs_notice "Executing make $MAKEJOBS $MAKEFLAGS $DESTVAR=${DEST:-$FSROOT} ${MAKE_TARGETS[$i]}"
		make $MAKEJOBS $MAKEFLAGS $DESTVAR=${DEST:-$FSROOT} ${MAKE_TARGETS[$i]}
	done
}

walk_pkg_dir()
{
	local -i IGNERR=0 N_LOC
	OPTIND=1
	while getopts "a:c" FLAG
	do
		case "$FLAG" in
			c)
				IGNERR=1
				;;
			a)
				ACTS="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND - 1))

	for PKG in ${@}; do
		export PKG IGNERR LAST_TOOLCHAIN_LINK
		(
		set -aeET
		get_pkg_info $PKG
		[ "$PREFIX" = /tools ] && BUILDSYS_LINK=tools
		toolchain_link $BUILDSYS_LINK
		mkdir -p "$PKG_DIR"
		pushd "$PKG_DIR"
		for (( N_LOC = 0; N_LOC < ${#PKG_LOCATION[@]}; N_LOC++ )); do
			guess_pkg_info_from_location "${PKG_LOCATION[$N_LOC]}"
			#if [ "$SUFFIX" = 'src.rpm' ]; then
				## prevent build failure by rpm bug
				## https://bugzilla.redhat.com/show_bug.cgi?id=433795
				#IGNERR=1
			#fi
			for ACT in $ACTS; do
				if [ "$IGNERR" = 0 ]; then
					$ACT
				else
					set +eET
					$ACT || bs_notice "Ignoring errors"; continue
					set -eET
				fi
			done
			get_pkg_info $PKG
		done
		popd
		)
	done
}

pkg_unpack_patch()
{
	if [ "$PKG_LOCATION" = "dummy-file" ]; then
		mkdir -pv $SRC_DIR
		return
	fi

	cd $PKG_DIR
	if [ ! -f .unpacked-$PKG_NAME ] && [ ! -d "${SRC_DIR}" ]; then
		if [ -z "${PKG_LOCATION[$N_LOC]}" ]; then
			bs_error "No source file defined for \"$PKG\""
		fi
		if [ -d "${PKG_LOCATION[$N_LOC]}" ]; then
			bs_notice "Copying directory ${PKG_LOCATION[$N_LOC]}"
			cp -a "${PKG_LOCATION[$N_LOC]}" "$PKG_DIR"
		else
			get_file "${PKG_LOCATION[$N_LOC]}" "$PKG_POOL"
			bs_notice "Unpacking file ${PKG_FILE_NAME}"
			unpack "${PKG_POOL}/${PKG_FILE_NAME}"
		fi
		for ADDITION in ${ADDITIONS[@]}; do
			get_file "$ADDITION" "$PKG_POOL"
			bs_notice "Unpacking file ${ADDITION}"
			unpack "$PKG_POOL/${ADDITION##*/}" "$SRC_DIR/$DIR_ADDTION"
		done
		touch .unpacked-$PKG_NAME
	fi
	if [ ! -f .patched ]; then
		pushd "$SRC_DIR"
		for PATCH in ${PATCHES[@]}; do
			get_file "$PATCH" "$PKG_POOL"
			case $PATCH in
				*.patch.gz)
					gzip -d --stdout $PKG_POOL/${PATCH##*/} | patch --verbose -Np1
					;;
				*.patch.bz2)
					bzip2 -d --stdout $PKG_POOL/${PATCH##*/} | patch --verbose -Np1
					;;
				*.patch.xz)
					xz -d --stdout $PKG_POOL/${PATCH##*/} | patch --verbose -Np1
					;;
				*.patch)
					patch --verbose -Np1 < $PKG_POOL/${PATCH##*/}
					;;
				*)
					bs_error "Unknown patch format"
					;;
			esac
		done
		if [[ "$SUFFIX" = 'src.rpm' && -r "$RPM_SPEC" ]]; then
			sed -i -e '/^%clean/,/^$/d' "$RPM_SPEC"
			pkg_rpm_prep
		fi
		# Execute any script or binary with env variables exported for it
		# pre-build can be used to do patching job
		# Only bash and perl supported for scripting as of now
		if declare -F pre-build; then
			(pre-build)
		elif [ -f ${PKG_SPECDIR}/pre-build ]; then
			${PKG_SPECDIR}/pre-build
		fi
		popd
		touch .patched
	fi
}

pkg_make_install()
{
	local -i i

	if [ ! -f ".built-$PKG_NAME" ]; then
		pushd "$SRC_DIR"
		bs_notice "Building package ${PKG} in $SRC_DIR"
		if [ -x ${PKG_SPECDIR}/build ]; then
			${PKG_SPECDIR}/build
			if [ ! -d $MAKEDIR ]; then
				ln -vs "$SRC_DIR" "$MAKEDIR"
			fi
		else
			if [ "$MAKEDIR" != "$PKG_DIR/build-$PKG_NAME" ]; then
				cd $MAKEDIR
			fi
			if [ -r Makefile ] && [ ! -x configure ]; then
				MAKEFLAGS="PREFIX=$PREFIX prefix=$PREFIX $MAKEJOBS $MAKEFLAGS"
				for (( i = 0; i < ${#MAKE_TARGETS[@]}; i++ )); do
					bs_notice "Executing make $MAKEFLAGS" "$CROSS_MAKEOPTS ${MAKE_TARGETS[$i]}"
					make $MAKEFLAGS $CROSS_MAKEOPTS ${MAKE_TARGETS[$i]}
				done
			elif [ -x configure ]; then
				if [ ! -f ${PKG_DIR}/".configured-$PKG_NAME" ]; then
					case $PKG_NAME in
						qt-everywhere-opensource-src)
							;;
						*)
							precede_conf_opts "--prefix=$PREFIX"
							;;
					esac
					[ -n "$BUILDSYS_BUILD" ] && precede_conf_opts "--build=$BUILDSYS_BUILD"
					[ -n "$BUILDSYS_HOST" ] && precede_conf_opts "--host=$BUILDSYS_HOST"
					if [ ! -d $MAKEDIR ]; then
						mkdir -p $MAKEDIR
					fi
					pushd $MAKEDIR
					bs_notice "Executing configure ${CONFIGFLAGS[@]}"
					$SRC_DIR/configure ${CONFIGFLAGS[@]}
					popd
					touch ${PKG_DIR}/".configured-$PKG_NAME"
				fi
				cd $MAKEDIR
				MAKEFLAGS="$MAKEJOBS $MAKEFLAGS"
				for (( i = 0; i < ${#MAKE_TARGETS[@]}; i++ )); do
					bs_notice "Executing make $MAKEFLAGS ${MAKE_TARGETS[$i]}"
					make $MAKEFLAGS ${MAKE_TARGETS[$i]}
				done
			elif [ -r ${PKG_NAME}.pro ]; then
				qmake
				make
			elif [ -r Makefile.PL ]; then
				perl Makefile.PL
				make
				make install
			elif [ -r "$RPM_SPEC" ]; then
				pkg_rpm_install
			else
				bs_error "Don't know how to build package $PKG."
			fi
			if [ ! -d $MAKEDIR ]; then
				ln -vfs "$SRC_DIR" "$MAKEDIR"
			fi
		fi
		popd
		touch ".built-$PKG_NAME"
	fi
	if [ ! -f ".done-$PKG_NAME" ]; then
		# post-install can be used to fix installation problems
		if declare -F post-install; then
			pushd /
			(post-install)
			popd
		elif [ -f ${PKG_SPECDIR}/post-install ]; then
			pushd /
			${PKG_SPECDIR}/post-install
			popd
		fi
		if [ -n "$SERVICE_FILE" ]; then
			install -v -m 754 -D ${PKG_SPECDIR}/$SERVICE_FILE /lib/services/$PKG_NAME
		fi
		touch ".done-$PKG_NAME"
	else
		bs_notice "${PKG} has already been built. Skip."
		return
	fi
}

pkg_make_clean()
{
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	cd $MAKEDIR
	if ! grep -q '^clean:' Makefile; then
		bs_error "\"${PKG_NAME}\" does not support make clean"
	fi
	bs_notice "Cleaing \"$PKG\"..."
	make clean
	cd $PKG_DIR
	rm -f ".done-$PKG_NAME" ".built-$PKG_NAME"
}

pkg_make_distclean()
{
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	cd $MAKEDIR
	bs_notice "Dist cleaing \"$PKG\"..."
	if grep -q '^distclean:' Makefile; then
		make distclean
	elif grep -q '^clean:' Makefile; then
		make clean
	else
		bs_error "\"${PKG_NAME}\" does not support make clean or distclean"
	fi
	cd $PKG_DIR
	rm -rf ".done-$PKG_NAME" ".built-$PKG_NAME" ".configured-$PKG_NAME" $MAKEDIR
}

pkg_make_uninstall()
{
	local LINE=
	if [ ! -f ".installed-$PKG_NAME" ]; then
		bs_notice "$PKG not installed, skipping..."
		return
	fi
	if [ -d $FAKEROOT ]; then
		cd $FAKEROOT
		find | tac | while read LINE; do \
			rm -v $FSROOT/$LINE 2> /dev/null || \
			rmdir -p --ignore-fail-on-non-empty $FSROOT/$LINE 2> /dev/null; \
		done
	elif [ -d $MAKEDIR ]; then
		cd $MAKEDIR
		bs_notice "Uninstalling \"$PKG\"..."
		make_fakeroot "$PKG_NAME" uninstall
	fi
	rm -f $PKG_DIR/".installed-$PKG_NAME"
}

pkg_dest_install()
{
	local -i i
	if [ -f $PKG_DIR/".installed-$PKG_NAME" ]; then
		bs_notice "$PKG has already been installed, skipping..."
		return
	fi
	if [ ! -d $MAKEDIR ]; then
		return
	fi
	if [ "$TARGET_INSTALL" = n ]; then
		bs_notice "Package \"$PKG\" is not required to be installed on target."
		return
	fi
	bs_notice "Installing \"$PKG\" into ${FSROOT}..."
	if [ $SUFFIX = 'src.rpm' ]; then
		pkg_rpm_dest_install
	elif [ -x ${PKG_SPECDIR}/build ]; then
		${PKG_SPECDIR}/build $FSROOT
	else
		cd $MAKEDIR
		make_fakeroot "$PKG_NAME" ${MAKE_TARGETS[@]}
	fi
	# post-install can be used to fix target installation problems
	if declare -F post-install; then
		pushd "$FAKEROOT"
		(post-install)
		popd
	elif [ -x ${PKG_SPECDIR}/post-install ]; then
		pushd "$FAKEROOT"
		${PKG_SPECDIR}/post-install
		popd
	fi
	cd "$FAKEROOT"
	for (( i = 0; i < ${#INSTALL_FILES[@]}; i++ )); do
		cp -av --parents ${INSTALL_FILES[$i]#/} $FSROOT
	done
	if [ -n "$SERVICE_FILE" ]; then
		install -v -m 754 -D ${PKG_SPECDIR}/$SERVICE_FILE lib/services/$PKG_NAME
	fi
	cd -
	touch $PKG_DIR/".installed-$PKG_NAME"
}

pkg_remove()
{
	if [ -r "$PKG_POOL/$PKG_FILE_NAME" ] || [ -n "${PKG_LOCATION[$N_LOC]}" ]; then
		cd $BUILD_DIR
		bs_notice "Removing $PKG_DIR"
		rm -rf "$PKG_DIR"
	elif [ -d "$MAKEDIR" ]; then
		pkg_make_distclean
	fi
}

pkg_rpm_prep()
{
	bs_notice "Executing rpmbuild -vv -bp"
	rpmbuild -vv -bp --nodeps \
		--define "_sourcedir $SRC_DIR" \
		--define "_builddir $MAKEDIR" \
		--define "_topdir $PKG_DIR" \
		--define "_rpmdir $GEN_DIR" \
		--define "_specdir $SRC_DIR" \
		--define "_prefix $PREFIX" \
		--define "debug_package %{nil}" \
		"$RPM_SPEC"
}

pkg_rpm_install()
{
	bs_notice "Executing rpmbuild -vv -bc --short-circuit"
	rpmbuild -vv -bc --short-circuit --nodeps \
		--define "_sourcedir $SRC_DIR" \
		--define "_builddir $MAKEDIR" \
		--define "_topdir $PKG_DIR" \
		--define "_rpmdir $GEN_DIR" \
		--define "_specdir $SRC_DIR" \
		--define "_prefix $PREFIX" \
		--define "_buildrootdir %{_topdir}/files" \
		--define "debug_package %{nil}" \
		"$RPM_SPEC"
	bs_notice "Executing rpmbuild -vv -bi --short-circuit"
	rpmbuild -vv -bi --short-circuit --nodeps \
		--define "_sourcedir $SRC_DIR" \
		--define "_builddir $MAKEDIR" \
		--define "_topdir $PKG_DIR" \
		--define "_rpmdir $GEN_DIR" \
		--define "_specdir $SRC_DIR" \
		--define "_prefix $PREFIX" \
		--define "_buildrootdir %{_topdir}/files" \
		--define "debug_package %{nil}" \
		"$RPM_SPEC"
	cd $FAKEROOT
	cp -a . /
}

pkg_rpm_dest_install()
{
	bs_notice "Executing rpmbuild -vv -bi --short-circuit"
	rpmbuild -vv -bi --short-circuit --nodeps \
		--define "_sourcedir $SRC_DIR" \
		--define "_builddir $MAKEDIR" \
		--define "_topdir $PKG_DIR" \
		--define "_rpmdir $GEN_DIR" \
		--define "_srcrpmdir $GEN_DIR" \
		--define "_specdir $SRC_DIR" \
		--define "_prefix $PREFIX" \
		--define "_buildrootdir %{_topdir}/files" \
		--define "debug_package %{nil}" \
		"$RPM_SPEC"
}

pkg_rpmbuild()
{
	case $SUFFIX in
		src.rpm|SRC.RPM)
			bs_notice "Executing rpmbuild -vv --rebuild"
			rpmbuild -vv --rebuild \
				--define "_sourcedir $SRC_DIR" \
				--define "_builddir $MAKEDIR" \
				--define "_topdir $PKG_DIR" \
				--define "_rpmdir $GEN_DIR" \
				--define "_srcrpmdir $GEN_DIR" \
				--define "_specdir $SRC_DIR" \
				--define "_prefix $PREFIX" \
				--define "_buildrootdir %{_topdir}/files" \
				--define "debug_package %{nil}" \
				$PKG_POOL/$PKG_FILE_NAME
			;;
		tar.*)
			bs_notice "Executing rpmbuild -vv -ta"
			rpmbuild -vv -ta \
				--define "_sourcedir $SRC_DIR" \
				--define "_builddir $MAKEDIR" \
				--define "_topdir $PKG_DIR" \
				--define "_rpmdir $GEN_DIR" \
				--define "_srcrpmdir $GEN_DIR" \
				--define "_specdir $SRC_DIR" \
				--define "_prefix $PREFIX" \
				--define "_buildrootdir %{_topdir}/files" \
				--define "debug_package %{nil}" \
				$PKG_POOL/$PKG_FILE_NAME
			;;
		*)
			bs_error "$PKG does not support rpmbuild"
			;;
	esac
}

clean_pkgs()
{
	walk_pkg_dir -a pkg_make_clean ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} clean complete."
}

distclean_pkgs()
{
	walk_pkg_dir -c -a pkg_make_distclean ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} dist clean complete."
}

uninstall_pkgs()
{
	bs_notice "${PKG_LIST[@]} are going to be uninstalled."
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_pkg_dir -c -a pkg_make_uninstall ${PKG_LIST[@]}
	bs_notice "Package ${PKG_LIST[@]} uninstall complete."
}

build_pkgs()
{
	bs_notice "Building packages:"
	echo '========================================='
	printf "%s\n" "${PKG_LIST[@]}"
	echo '========================================='
	echo
	echo -n "Calculating dependencies..."
	BUILD_LIST="$(resolve_deps ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	BUILD_LIST=(${BUILD_LIST#*,})
	echo
	echo
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be built after resolving dependencies:"
	echo '========================================='
	printf "%s\n" "${BUILD_LIST[@]}"
	echo '========================================='
	echo

	if [ -z "$CONTINUE" ]; then
		bs_notice "Building package(s) \"${PKG_LIST[@]}\"..."
		walk_pkg_dir -c -a "pkg_remove" ${PKG_LIST[@]}
	else
		bs_notice "Continue building package(s) \"${PKG_LIST[@]}\"..."
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]} ${BUILD_LIST[@]}
	bs_notice "Package(s) \"${PKG_LIST[@]}\" build complete."
}

install_pkgs()
{
	bs_notice "Installing packages:"
	echo '========================================='
	printf "%s\n" "${PKG_LIST[@]}"
	echo '========================================='
	echo
	echo -n "Calculating dependencies..."
	BUILD_LIST="$(resolve_deps ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	BUILD_LIST=(${BUILD_LIST#*,})
	echo
	echo
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be built after resolving dependencies:"
	echo '========================================='
	printf "%s\n" "${BUILD_LIST[@]}"
	echo '========================================='
	echo

	pushd $FSROOT
	if [ -z "$CONTINUE" ]; then
		walk_pkg_dir -c -a pkg_make_uninstall ${BUILD_LIST[@]}
		bs_notice "Cleaning packages and ${FSROOT}"
		rm -rf * .[!.]*
	else
		bs_notice "Continue installing package(s) \"${PKG_LIST[@]}\"..."
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]} ${BUILD_LIST[@]}
	walk_pkg_dir -a pkg_dest_install ${PKG_LIST[@]}
	popd
	bs_notice "Package(s) \"${PKG_LIST[@]}\" install complete."
}

unpack_pkgs()
{
	if [ -z "$CONTINUE" ]; then
		bs_notice "Unpacking package(s) \"${PKG_LIST[@]}\"..."
		walk_pkg_dir -c -a pkg_remove ${PKG_LIST[@]}
	else
		bs_notice "Continue unpacking package(s) \"${PKG_LIST[@]}\"..."
	fi
	walk_pkg_dir -a pkg_unpack_patch ${PKG_LIST[@]}
	bs_notice "Package(s) \"${PKG_LIST[@]}\" unpack complete."
}

strip_rootfs()
{
	local LOCDIR LOCALE
	OPATH=$PATH
	PATH=/tools/bin
	bs_notice "Stripping file system in ${PWD}..."
	[ -h ./$PREFIX/lib/rpm ] && rm -v ./$PREFIX/lib/rpm
	[ $PREFIX = /tools ] || find . -name "*.a" -or -name "*.la" | xargs rm -rvf
	find . -type f -executable -print0 | xargs -0 file -Ni 2> /dev/null \
		| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-unneeded 2> /dev/null || true
	#EXE_LIST=$(find . -type f -executable -print0 | xargs -0 file -Ni 2> /dev/null || true)
	#if [ -n "$EXE_LIST" ]; then
		#echo "$EXE_LIST" | grep -F -e 'application/x-executable; charset=binary' \
			#| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-all 2> /dev/null || true
		#echo "$EXE_LIST" | grep -F -e 'application/x-sharedlib; charset=binary' \
			#| cut -d':' -f1 | xargs ${STRIP:-strip} -v --strip-debug 2> /dev/null || true
	#fi
	find ./$PREFIX/include -mindepth 1 ! -name pyconfig.h | xargs rm -rvf
	rmdir --ignore-fail-on-non-empty ./$PREFIX/include || true
	rm -rvf ./{include,share} ./${PREFIX}/share/{aclocal,awk,doc,getopt,info,man,pkgconfig,readline,vim} \
		./${PREFIX}/{doc,info,man,kernel-headers} ./$PREFIX/lib/pkgconfig .bse_init
	if [ "$LOCALES" != all ] && [ -d ./${PREFIX}/share/locale ]; then
		pushd ./${PREFIX}/share/locale
		for LOCDIR in *; do
			if [ -d $LOCDIR ]; then
				for LOCALE in $LOCALES; do
					if [ $LOCDIR = $LOCALE ]; then
						continue 2
					fi
				done
				rm -rvf $LOCDIR
			fi
		done
		popd
	fi
	PATH=$OPATH
	bs_notice "RootFS stripped in $FSROOT"
}

tar_pkgs()
{
	install_pkgs
	cd $FSROOT
	strip_rootfs
	tar -Jcvf $GEN_DIR/$IMG_NAME.tar.xz .
	bs_notice "File $IMG_NAME.tar.xz generated successfully"
}

ext4_pkgs()
{
	local FS_SIZE
	IMG_EXT4=$GEN_DIR/$IMG_NAME.ext4

	echo -n "Calculating dependencies..."
	BUILD_LIST="$(resolve_deps tools.conf/e2fsprogs ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	INSTALL_LIST=(${BUILD_LIST#*,})
	echo
	echo
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be installed after resolving dependencies:"
	echo '========================================='
	printf "%s\n" " ${INSTALL_LIST[@]}"
	echo '========================================='

	pushd $FSROOT
	if [ -z "$CONTINUE" ]; then
		walk_pkg_dir -c -a pkg_make_uninstall ${INSTALL_LIST[@]}
		bs_notice "Cleaning packages and ${FSROOT}"
		rm -rf * .[!.]*
	else
		bs_notice "Continue installing package(s) \"${PKG_LIST[@]}\"..."
	fi

	if [ ! -f .bse_init ] && declare -F configure_fs > /dev/null; then
		bs_notice "Creating essential directories and files in ${PWD}"
		configure_fs
		touch .bse_init
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]}
	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install pkg_dest_install" ${INSTALL_LIST[@]}
	strip_rootfs
	if [ -z "$BUILDSYS_HOST" ]; then
		chroot $FSROOT pwconv
		chroot $FSROOT grpconv
		set_passwd root "$ROOTPASSWD" || true
	fi

	FS_SIZE=$(du -sb . | cut -f1)
	dd if=/dev/zero of=$IMG_EXT4 bs=1 count=1 seek=$((FS_SIZE + FS_SIZE/5))
	mkfs.ext4 -F $IMG_EXT4
	mkdir -pv /tmp/$$
	mount -o loop -t ext4 $IMG_EXT4 /tmp/$$
	bs_notice "Copying files into ext4 file system"
	cp -a . /tmp/$$
	umount /tmp/$$
	rmdir -v /tmp/$$
	e2fsck -yf $IMG_EXT4
	resize2fs -M $IMG_EXT4
	popd
	bs_notice "File $IMG_NAME.ext4 generated successfully"
}

iso_pkgs()
{
	ISO_ROOT=$DEV_ROOT/ISOROOT
	FSROOT=$ISO_ROOT
	mkdir -pv $ISO_ROOT

	echo -n "Calculating dependencies..."
	BUILD_LIST="$(resolve_deps $(remove_from_list kernel ${PKG_LIST[@]}) kernel-cd isolinux grub)"
	TOOLS_LIST=(${BUILD_LIST%,*})
	INSTALL_LIST=(${BUILD_LIST#*,})
	echo
	echo
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be installed after resolving dependencies:"
	echo '========================================='
	printf "%s\n" " ${INSTALL_LIST[@]}"
	echo '========================================='

	pushd $FSROOT
	if [ -z "$CONTINUE" ]; then
		walk_pkg_dir -c -a pkg_make_uninstall ${INSTALL_LIST[@]}
		bs_notice "Cleaning packages and ${FSROOT}"
		rm -rf * .[!.]*
	else
		bs_notice "Continue installing package(s) \"${PKG_LIST[@]}\"..."
	fi

	if [ ! -f .bse_init ] && declare -F configure_fs > /dev/null; then
		bs_notice "Creating essential directories and files in ${PWD}"
		configure_fs
		touch .bse_init
	fi

	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]}
	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install pkg_dest_install" ${INSTALL_LIST[@]}
	strip_rootfs
	if [ -z "$BUILDSYS_HOST" ]; then
		chroot $FSROOT pwconv
		chroot $FSROOT grpconv
		set_passwd root "$ROOTPASSWD" || true
	fi

	cat > etc/rc.d/init.d/create_ramdisk <<- "EOF"
	#!/bin/sh
	# SET UP SOME VARIABLES FOR DEVICES AND DIRECTORIES
	dev_ram=/dev/ram1
	dev_ram2=/dev/ram2
	dir_ramdisk=/fake/ramdisk
	dir_needwrite=/fake/needwrite
	# SOURCE THE FUNCTIONS FILE
	source /etc/rc.d/init.d/functions
	case "$1" in
		start)
			# CREATE THE RAM DISK
			echo "Creating ext2fs on $dev_ram..."
			/sbin/mke2fs -m 0 -i 1024 -q $dev_ram > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# MOUNT THE RAM DISK
			echo "Mounting ramdisk on $dir_ramdisk..."
			mount -n $dev_ram $dir_ramdisk -t ext2
			evaluate_retval
			sleep 1
			# COPY FILES TO THE RAM DISK
			echo "Copying files to ramdisk..."
			cp -a $dir_needwrite/* $dir_ramdisk > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# CREATE SECOND RAMDISK
			echo "Creating second ramdisk"
			/sbin/mke2fs -m 0 -i 1024 -q $dev_ram2 > /dev/null 2>&1
			evaluate_retval
			sleep 1
			# MOUNT SECOND RAMDISK
			echo "Mounting second ram disk"
			mount -n $dev_ram2 $dir_needwrite -t ext2
			evaluate_retval
			sleep 1
			# COPY FILES TO THE SECOND RAMDISK
			echo "Copying files to the second ram disk"
			cp -a $dir_ramdisk/* $dir_needwrite
			evaluate_retval
			sleep 1
			# UNMOUNT THE FIRST RAMDISK
			echo "Unmounting and clearing first ram disk"
			umount -n $dir_ramdisk > /dev/null 2>&1
			blockdev --flushbufs /dev/ram1
			evaluate_retval
			sleep 1
			;;
		*)
			echo "Usage: $0 {start}"
			exit 1
			;;
	esac
	EOF

	chmod -v 0755 etc/rc.d/init.d/create_ramdisk
	ln -vfs ../init.d/create_ramdisk etc/rc.d/rcS.d/S00create_ramdisk

	cat > etc/fstab <<- "EOF"
	# Begin /etc/fstab for a bootable CD

	# file system  mount-point  type   options         dump  fsck
	#                                                        order
	CDROM     /            iso9660  ro        1     1
	#/dev/EDITME     swap         swap   pri=1           0     0
	proc           /proc        proc   nosuid,noexec,nodev        0     0
	sysfs          /sys         sysfs  nosuid,noexec,nodev        0     0
	devtmpfs          /dev         devtmpfs  mode=0755,nosuid        0     0
	devpts         /dev/pts     devpts gid=5,mode=620  0     0
	tmp            /tmp         tmpfs  defaults        0     0
	tmpfs            /run         tmpfs  rw,noexec,nosuid,size=10%,mode=0755        0     0
	/dev/ram2		/fake/needwrite		ext2 defaults 	0 	0
	# End /etc/fstab
	EOF

	rm -vf etc/rc.d/rcS.d/S30checkfs
	#rm -vf etc/rc.d/rcS.d/S40mountfs
	sed -i -e '/remount/d' -e '48a\
		mount -f /fake/needwrite || failed=1
	' etc/rc.d/init.d/mountfs
	#sed -i -e 's/remount,rw/remount,ro/g' etc/rc.d/init.d/mountfs
	mknod lib/udev/devices/loop0 b 7 0
	mkdir -pv dev
	local i
	for i in 1 2; do
		mknod dev/ram$i b 1 $i
	done
	mknod dev/null    c  1  3
	mknod dev/zero    c  1  5
	mknod dev/console c  5  1
	mknod dev/ttyS0   c  4 64

	rm -rvf fake
	mkdir -vp fake/{needwrite,ramdisk}
	mv -vf etc/ var/ root/ home/ fake/needwrite/
	ln -vfs fake/needwrite/etc etc
	ln -vfs fake/needwrite/var var
	ln -vfs fake/needwrite/root root
	ln -vfs fake/needwrite/home home

	dd if=/dev/zero of=boot/initrd bs=1k count=1 seek=8191
	mke2fs -v -m 0 -i 1024 -F boot/initrd
	mount -vo loop boot/initrd mnt
	pushd mnt
	mkdir -vp bin lib dev proc mnt
	mknod dev/ram0    b  1  0
	mknod dev/null    c  1  3
	mknod dev/zero    c  1  5
	mknod dev/console c  5  1
	mknod dev/ttyS0   c  4 64
	mknod dev/sr0     b 11  0
	mknod dev/sr1     b 11  1
	mknod dev/sda     b  8  0
	mknod dev/sdb     b  16  0
	mknod dev/sdc     b  32  0
	mknod dev/sdd     b  48  0
	mknod dev/hda     b  3  0
	mknod dev/hdb     b  3  64
	mknod dev/hdc     b  22  0
	mknod dev/hdd     b  22 64
	mknod dev/hde     b  33  0
	cp -v $ISO_ROOT/bin/{bash,mount,grep,umount,echo,dd} bin/
	cp -v $ISO_ROOT/usr/bin/test bin/
	cp -v $ISO_ROOT/usr/sbin/chroot bin/
	cp -v $ISO_ROOT/sbin/pivot_root bin/
	ln -vfs bash bin/sh
	ln -vfs test bin/[
	cp -v $ISO_ROOT/lib/{libncursesw.so.5,libdl.so.2} lib/
	cp -v $ISO_ROOT/lib/{libc.so.6,libreadline.so.6} lib/
	cp -v $ISO_ROOT/lib/{libhistory.so.6,libblkid.so.1,libuuid.so.1} lib/
	cp -v $ISO_ROOT/lib/{libpthread.so.0,librt.so.1} lib/
	if [ -f $ISO_ROOT/lib/ld-linux.so.2 ] 
	then 
		cp -v -f $ISO_ROOT/lib/ld-linux.so.2 lib/
	fi
	if [ -f $ISO_ROOT/lib/ld.so.1 ] 
	then 
		cp -v -f $ISO_ROOT/lib/ld.so.1 lib/
	fi
	cp -v $ISO_ROOT/bin/{cat,sleep,mknod} bin/

	cat > linuxrc <<- EOF
	#!/bin/sh
	#ID is the volume id / label of the boot CD that will be looked for.
	ID="${IMG_NAME::32}"
	EOF

	cat >> linuxrc <<- "EOF"
	TMP_MOUNT="/mnt"

	PATH="/bin:/sbin:/usr/bin:/usr/sbin"

	#this script searches for cdrom devices and then tries to find
	#the boot CD in order to mount it as / (rootfs)

	#you need following programs:
	#- /bin/sh (e.g. bash)
	#- echo
	#- [ (which is linked to test)
	#- mount
	#- umount
	#- grep
	#- pivot_root
	#- chroot

	#you need following devices:
	#- /dev/hd*, /dev/sd*, /dev/sr* or /dev/cdrom*
	#- /dev/null

	#you need following directories:
	#- /proc
	#- $TMP_MOUNT

	CHECK_TYPE="try_mount"

	if [ ! -d "/proc/" ]; then
		mkdir /proc
	fi

	mount -n proc /proc -t proc

	#1. Create a list of possible cdrom devices.

	CDROM_LIST="/dev/sr0 /dev/sr1 /dev/cdrom /dev/hda /dev/hdb /dev/hdc /dev/hdd /dev/hde /dev/sda /dev/sdb"

	#2. now we try to find the boot CD (we use ID as identification)

	CDROM_DEVICE=""
	echo "Using $CHECK_TYPE"
	for cdrom_device in $CDROM_LIST
	do
		echo -n "Checking $cdrom_device ... "

		if [ "$CHECK_TYPE" = "try_mount" ]; then
			mount -n -t iso9660 $cdrom_device $TMP_MOUNT > /dev/null 2>&1
			media_found=$?
		fi

		if [ $media_found -eq 0 ]; then

			echo -n "media found"
			if [ "$CHECK_TYPE" = "try_mount" ]; then
				[ $(dd if=$cdrom_device bs=1 count=32 skip=32808 2> /dev/null) = "$ID" ]
				buildsys_media=$?
			fi

			if [ "$CHECK_TYPE" = "try_mount" ]; then
				umount -n $cdrom_device > /dev/null 2>&1
			fi

			if [ $buildsys_media -eq 0 ]; then
				echo ", BuildSys generated boot CD found. Ready!"
				CDROM_DEVICE="$cdrom_device"
				break;
			else
				echo ", not BuildSys generated boot CD."
			fi

		else
			echo "no media "
		fi
	done

	#3. mount CD as / (root fs)
	if [ "$CDROM_DEVICE" = "" ]; then

		echo "No boot CD found!!!  You will have to fix this to continue"
		echo "do: mount -n -o ro -t iso9660 'your cd device' $TMP_MOUNT"
		echo "Then exit shell to continue"
		bash

	else

		echo "Booting from $CDROM_DEVICE ..."

		mount -n -o ro -t iso9660 $CDROM_DEVICE $TMP_MOUNT
	fi
	cd $TMP_MOUNT
	#sed -i -e "s/CDROM/$CDROM_DEVICE/g" ./etc/fstab
	pivot_root . mnt
	umount -n /mnt/proc
	exec chroot . sh -c 'umount -n /mnt >/dev/null 2>&1;\
		exec -a init.new /sbin/init 3'\
		<dev/console >dev/console 2>&1

	EOF
	chmod -v 0755 linuxrc
	popd
	while ! umount -v $ISO_ROOT/mnt; do
		sleep 1
	done
	gzip $ISO_ROOT/boot/initrd
	genisoimage -R -l -L -D -b isolinux/isolinux.bin -c isolinux/boot.cat \
		-no-emul-boot -boot-load-size 4 -boot-info-table -V "$IMG_NAME" \
		. > $GEN_DIR/$IMG_NAME.iso
	popd
	bs_notice "Image $IMG_NAME.iso generated successfully"
}

rpm_pkgs()
{
	local PKG
	bs_notice "Generating rpm packages:"
	echo '========================================='
	printf "%s\n" "${PKG_LIST[@]}"
	echo '========================================='
	echo
	echo -n "Calculating dependencies..."
	BUILD_LIST="$(resolve_deps rpm ${PKG_LIST[@]})"
	TOOLS_LIST=(${BUILD_LIST%,*})
	BUILD_LIST=(${BUILD_LIST#*,})
	echo
	echo
	if [ ${#TOOLS_LIST[@]} != 0 ]; then
		bs_notice "Packages to be built for tools:"
		echo '========================================='
		printf "%s\n" "${TOOLS_LIST[@]}"
		echo '========================================='
		echo
	fi
	bs_notice "Packages to be built after resolving dependencies:"
	echo '========================================='
	printf "%s\n" "${BUILD_LIST[@]}"
	echo '========================================='
	echo

	if [ -z "$CONTINUE" ]; then
		bs_notice "Building package(s) \"${PKG_LIST[@]}\"..."
		walk_pkg_dir -c -a "pkg_remove" ${PKG_LIST[@]}
	else
		bs_notice "Continue building package(s) \"${PKG_LIST[@]}\"..."
	fi

	for PKG in ${PKG_LIST[@]}; do
		BUILD_LIST=($(remove_from_list $PKG $BUILD_LIST))
	done
	walk_pkg_dir -a "pkg_unpack_patch pkg_make_install" ${TOOLS_LIST[@]} ${BUILD_LIST[@]}
	walk_pkg_dir -a "pkg_rpmbuild" ${PKG_LIST[@]}
	bs_notice "RPM package(s) \"${PKG_LIST[@]}\" generated successfully in GEN directory."
}

in_list()
{
	local i j="${1}"
	shift
	for i in ${@}; do
		if [ "$i" = "$j" ]; then
			return 0
		fi
	done
	return 1
}

pkgname_in_list()
{
	local i j="${1}"
	shift
	for i in ${@}; do
		export i j
		(
		get_pkg_info $i > /dev/null
		if [ "$PKG_NAME" = "$j" ]; then
			exit 1
		fi
		)
		if [ $? = 1 ]; then
			return 0
		fi
	done
	return 1
}

remove_from_list()
{
	local i j="$1"
	local -a LIST=
	shift
	for i in ${@}; do
		if [ "$i" != "$j" ]; then
			LIST+=($i)
		fi
	done
	echo -n ${LIST[@]}
}

get_pkg_info()
{
	local PKG="$1" SPECFOUND=0
	unset PKG_NAME VERSION SRC_DIR PKG_FILE_NAME SUFFIX RPM_SPEC MAKEDIR
	CONF_NAME=$(dirname ${PKG}) PKG_DIR_NAME=$(basename ${PKG})
	PKG_DIR="${BUILD_DIR}/${PKG}"
	MAKE_TARGETS=('' install)
	if [ $(dirname $PKG) != . ]; then
		source $INCDIR/$(dirname $PKG)
		parse_conf_var
		PKG=$(basename $PKG)
	fi
	for SPECDIR in ${SPECDIRS[@]} SPECS; do
		PKG_SPECDIR="$DEV_ROOT/$SPECDIR/$PKG"
		for SPECFILE in "${PKG_SPECDIR}/spec" "${PKG_SPECDIR}/${SPECNAME}"; do
			if [ -f "$SPECFILE" ]; then
				bs_notice "Reading $SPECFILE"
				source $SPECFILE
				: $((SPECFOUND |= 1))
			fi
		done
		[ $SPECFOUND = 1 ] && break
	done
	if [ $SPECFOUND = 0 ]; then
		bs_error "${PKG}'s spec not found"
	fi
}

deps_of()
{
	(
	get_pkg_info ${1} > /dev/null
	for DEP in ${DEPS[@]}; do
		if [ "$CONF_NAME" = . ]; then
			echo -n "${DEP} "
		else
			echo -n "$CONF_NAME/${DEP#*/} "
		fi
	done
	)
}

tool_deps_of()
{
	(
	get_pkg_info ${1} > /dev/null
	guess_pkg_info_from_location "${PKG_LOCATION}"
	case "$SUFFIX" in
		src.rpm|SRC.RPM)
			RPM_TOOLS=(cpio rpm buildsys-rpm-config) 
			for TOOL in ${RPM_TOOLS[@]}; do
				if ! in_list "$TOOL" ${TOOL_DEPS[@]}; then
					if ! in_list "tools.conf/$TOOL" ${TOOL_DEPS[@]}; then
						TOOL_DEPS+=($TOOL)
					fi
				fi
			done
			;;
	esac
	case "${PKG_LOCATION[$N_LOC]}" in
		https://* | ftps://*)
			TOOL_DEPS+=(ssl-cert wget)
			;;
	esac
	for DEP in ${TOOL_DEPS[@]}; do
		if [ "$CONF_NAME" = . ]; then
			echo -n "tools.conf/${DEP#*/} "
		else
			echo -n "$CONF_NAME/${DEP#*/} "
		fi
	done
	)
}

add_dep_pkg()
{
	local DEP
	UNRESOLVED_LIST+=(${1})
	for DEP in $(deps_of ${1}); do
		if ! in_list "$DEP" ${RESOLVED_LIST[@]}; then
			if in_list "$DEP" ${UNRESOLVED_LIST[@]}; then
				bs_error "Circular reference detected: $1 -> $DEP"
			fi
			add_dep_pkg "$DEP"
		fi
	done
	for DEP in $(tool_deps_of ${1}); do
		if ! in_list "$DEP" ${RESOLVED_TOOL_LIST[@]}; then
			if in_list "$DEP" ${UNRESOLVED_TOOL_LIST[@]}; then
				bs_error "Circular reference detected: $1 -> $DEP"
			fi
			add_dep_tool_pkg "$DEP"
		fi
	done
	RESOLVED_LIST+=(${1})
	UNRESOLVED_LIST=($(remove_from_list "${1}" ${UNRESOLVED_LIST[@]}))
}

add_dep_tool_pkg()
{
	local DEP
	UNRESOLVED_TOOL_LIST+=(${1})
	for DEP in $(tool_deps_of ${1}) $(deps_of ${1}); do
		if ! in_list "$DEP" ${RESOLVED_TOOL_LIST[@]}; then
			if in_list "$DEP" ${UNRESOLVED_TOOL_LIST[@]}; then
				bs_error "Circular reference detected: $1 -> $DEP"
			fi
			add_dep_tool_pkg "$DEP"
		fi
	done
	RESOLVED_TOOL_LIST+=(${1})
	UNRESOLVED_TOOL_LIST=($(remove_from_list "${1}" ${UNRESOLVED_TOOL_LIST[@]}))
}

resolve_deps()
{
	local -a RESOLVED_LIST=(${BSE_TOOLS[@]}) UNRESOLVED_LIST= RESOLVED_TOOL_LIST=(${BSE_TOOLS[@]}) UNRESOLVED_TOOL_LIST=
	local PKG

	for PKG in $@; do
		if [ $(dirname $PKG) = 'tools.conf' ]; then
			add_dep_tool_pkg $PKG
		else
			add_dep_pkg $PKG
		fi
	done
#	case $SDKARCH in
#		i?86|x86*)
#			;;
#		*)
			for (( i = 0; i < ${#RESOLVED_TOOL_LIST[@]}; i++ )); do
				RESOLVED_TOOL_LIST[i]="tools.conf/${RESOLVED_TOOL_LIST[i]#tools.conf/}"
			done
#			;;
#	esac
	echo "${RESOLVED_TOOL_LIST[@]:${#BSE_TOOLS[@]}},${RESOLVED_LIST[@]:${#BSE_TOOLS[@]}}"
}

bse_init()
{
	rm -rf bin boot etc home lib media mnt opt sbin srv tmp usr
	if declare -F configure_fs > /dev/null; then
		bs_notice "Creating essential directories and files in ${PWD}"
		configure_fs
	fi
	[ -x /bin/bash ] || ln -fsv /tools/bin/{bash,cat,echo,pwd,stty} /bin
	[ -x /usr/bin/perl ] || ln -sv /tools/bin/perl usr/bin
	[ -f /usr/lib/libgcc_s.so ] || ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib
	if [ ! -f /usr/lib/libstdc++.so ]; then
		ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib
		sed 's/tools/usr/' /tools/lib/libstdc++.la > /usr/lib/libstdc++.la
	fi
	[ -x bin/sh ] || ln -sv bash /bin/sh
	[ -x /usr/bin/env ] || ln -sv /tools/bin/env /usr/bin/env
}

print_help_and_exit()
{
	exec >&2
	echo -e "Usage:\n $(basename $0) [Options] Command PackageName ..."
	echo "Options:"
	echo " -c, --continue		Resume previous buildsys process"
	echo " -f FILE, --config FILE	Use FILE as build config"
	echo "			(default: build-${SDKARCH:-i686}.conf)"
	echo " -j N, --jobs N		Build with N jobs running concurrently"
	echo "			(default N = number of CPUs)"
	echo " -h, --help		Print this help"
	echo "Command:"
	echo " unpack			Unpack only, don't build the package"
	echo " build			Build only, don't make target rootfs"
	echo "			(This is default if no Command specified)"
	echo " install		Install packages to rootfs"
	echo " gentar			Generate root filesystem tarball"
	echo " genext4		Generate ext4 root filesystem"
	echo " geniso			Generate root filesystem installation cd"
	echo " genrpm			Generate rpm package"
	echo " clean			Clean packages"
	echo " distclean		Dist clean package build directories and rootfs"
	echo " uninstall		Uninstall package from root directory in SDE"
	echo "PackageName:"
	echo " \"all\"			Build all packages specified in config file"
	echo "			(default all for empty PackageName)"
	echo " \"package name\"		Single or multiple package names overriding config file"
	exit
}

main()
{
	echo "Executing \"$(basename $0) $OPTS_ORIG\" with ${BUILD_CONF} at ${START_TIME}"

	parse_conf_var

	export IMG_NAME="$(basename ${BUILD_CONF})-$(echo $TARGET_PKGS | tr -s [:blank:] | tr [:blank:] -)-$(date +%Y%m%d%H%M)"

	if [ -r /proc/cpuinfo ]; then
		CPUS=$(grep -F processor /proc/cpuinfo | wc -l)
		: ${MAKEJOBS:="-j $CPUS"}
	fi
	export MAKEJOBS

	if [ ! -f /.bse_init ]; then
		cd /
		bse_init
		touch /.bse_init
	fi

	cd "$DEV_ROOT"
	mkdir -pv $FSROOT
	${ACTION:-build_pkgs}
}

GETOPTS=$(getopt -o cf:j:h --long continue,config:,jobs:,help -n "$0" -- "$@")
[ $? != 0 ] && print_help_and_exit

eval set -- "$GETOPTS"
while true; do
	case "$1" in
		-c|--continue)
			export CONTINUE=1; shift
			;;
		-f|--config)
			BUILD_CONF="$2"
			if [ ! -f "$BUILD_CONF" ]; then
				BUILD_CONF="$INCDIR/${BUILD_CONF##*/}"
			fi
			if [ ! -f "$BUILD_CONF" ]; then
				bs_error "File \"$2\" not found"
				exit 1
			fi
			shift 2
			;;
		-j|--jobs)
			MAKEJOBS="$1 $2"
			shift 2
			;;
		-h|--help)
			print_help_and_exit
			;;
		--)
			shift ; break
			;;
		*)
			print_help_and_exit
			;;
	esac
done

if [ ! -d "$INCDIR" ]; then
	bs_error "Directory \"$INCDIR\" for global configuration not found"
fi

BSE_TOOLS=($(cat /tools/bsetools))
for (( i = 0; i < ${#BSE_TOOLS[@]}; i++ )); do
	BSE_TOOLS[i]="tools.conf/${BSE_TOOLS[i]}"
done
export BSE_TOOLS

set -a
source ${BUILD_CONF:="$INCDIR/build-${SDKARCH}.conf"}
set +a

case "$1" in
	clean)
		ACTION=clean_pkgs; shift
		;;
	distclean)
		ACTION=distclean_pkgs; shift
		;;
	uninstall)
		ACTION=uninstall_pkgs; shift
		;;
	unpack)
		ACTION=unpack_pkgs; shift
		;;
	build)
		ACTION=build_pkgs; shift
		;;
	install)
		ACTION=install_pkgs; shift
		;;
	gentar)
		ACTION=tar_pkgs; shift
		;;
	genext4)
		ACTION=ext4_pkgs; shift
		;;
	geniso)
		ACTION=iso_pkgs; shift
		;;
	genrpm)
		ACTION=rpm_pkgs; shift
		;;
	help)
		print_help_and_exit
		;;
esac

TARGET_PKGS="$@"
: ${TARGET_PKGS:=all}
if [ "$TARGET_PKGS" != all ]; then
	PKG_LIST=("$TARGET_PKGS")
elif [ "${#PKG_LIST[@]}" = 0 ]; then
	bs_error "No package to build. Please define PKG_LIST in ${BUILD_CONF}"
fi

trap quit ERR

if [ -z "$CONTINUE" ]; then
	rm -f "$DEV_ROOT/LOG/$(basename $BUILD_CONF).log"
fi
main $@ 2>&1 | tee -a "$DEV_ROOT/LOG/$(basename $BUILD_CONF).log"
mv "$DEV_ROOT/LOG/$(basename $BUILD_CONF).log" "$DEV_ROOT/LOG/$(basename $BUILD_CONF)-$START_TIME.log"
