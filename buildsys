#!/tools/bin/bash -eETh
# Wenbo Wang (1ball.w@gmail.com)

set -eETH
TIME=$(date +%F-%X)

quit()
{
	echo -e "\nError: Build interrupt..." >&2
	return 1
}

unpack()
{
	if [ -n "$3" ]; then
		TGT_DIR="$3"
	else
		TGT_DIR=.
	fi
	case $2 in
		tar.gz | tar.bz2 | tar.xz)
			tar -xvf "$1" -C "$TGT_DIR"
			;;
		zip)
			unzip "$1" -d "$TGT_DIR"
			;;
		*)
			echo "Error: Unkown package format for \"$1\"" >&2
			return 1
			;;
	esac
	return 0
}

guess_pkg_from_url()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$SUFFIX" in
			gz | bz2 | xz)
				SUFFIX="tar.$SUFFIX"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%.$SUFFIX}"
		PKG_NAME="${PKG_NAME%-*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$SRC_DIR" ]; then
		SRC_DIR="${PACKAGES}/${PKG}/${PKG_NAME}-${VERSION}"
	else
		SRC_DIR="${PACKAGES}/${PKG}/${SRC_DIR}"
	fi
}

walk_pkg_dir()
{
	local CONTINUE='false'
	OPTIND=1
	while getopts "bc" FLAG
	do
		case "$FLAG" in
			b)
				M='y'
				;;
			c)
				CONTINUE='true'
				;;
		esac
	done
	shift $((OPTIND - 1))
	for PKG in ${BUILD_LIST[@]}; do
		(
		set -e; set -E; set -T
		PKG_DIR="${PACKAGES}/${PKG}"
		if [ ! -d "$PKG_DIR" ]; then
			echo "Error: Package directory \"$PKG_DIR\" not found"
			return 1
		fi
		TGT_DIR="$PKG_DIR"
		source ${SPECS}/${PKG}/spec
		[ -n "$PKG_URL" ] && guess_pkg_from_url "$PKG_URL"
		if [ "$M" = y ]; then
			if [ -d "$PKG_DIR/build" ]; then
				MAKEDIR="$PKG_DIR/build"
			elif [ -d "$SRC_DIR" ]; then
				MAKEDIR="$SRC_DIR"
			else
				echo "Error: Cannot find make directory for \"$PKG\"." >&2
				exit 1
			fi
			TGT_DIR="$MAKEDIR"
			export MAKEDIR
		fi
		export PATCHES PKG PKG_DIR PKG_FILE_NAME SUFFIX VERSION PKG_NAME SRC_DIR
		pushd "$TGT_DIR"
		$@
		popd
		) || $CONTINUE
	done
}

walk_build_dir()
{
	walk_pkg_dir -b $@
}

build_pkgs()
{
	for PKG in ${BUILD_LIST[@]}; do
		if [ ! -r ${SPECS}/${PKG}/spec ]; then
			echo "Error: Cannot read spec defined for package \"${PKG}\" in ${SPECS}/${PKG}" >&2
			return 1
		fi
		(
		source ${SPECS}/${PKG}/spec
		[ -n "$PKG_URL" ] && guess_pkg_from_url "$PKG_URL"
		PKG_DIR="${PACKAGES}/${PKG}"
		mkdir -p ${PKG_DIR}
		cd ${PKG_DIR}
		if [ ! -f .unpacked ] && [ ! -d "${SRC_DIR}" ]; then
			if [ ! -r "$PKG_POOL/${PKG_FILE_NAME}" ] ; then
				if [ -n "$PKG_URL" ]; then
					wget -c -P "$PKG_POOL"/partial "$PKG_URL"
					mv "$PKG_POOL"/partial/$PKG_FILE_NAME "$PKG_POOL"
				else
					echo "Error: Package ${PKG_NAME}-${VERSION} not found." >&2
					return 1
				fi
			fi
			unpack "${PKG_POOL}/${PKG_FILE_NAME}" $SUFFIX
			touch .unpacked
		fi
		export PATCHES PKG PKG_DIR PKG_FILE_NAME SUFFIX VERSION PKG_NAME SRC_DIR
		# Execute any script or binary: shell, perl, python, java, etc... with env variables exported to it
		# pre-build can be used to do patching job
		if [ ! -f .patched ]; then
			pushd "$SRC_DIR"
			[ -r $SPECS/$PKG/*.patch ] && cp -v $SPECS/$PKG/*.patch "$PKG_POOL"
			for PATCH_URL in ${PATCHES[@]}; do
				PATCH_FILE=${PATCH_URL##*/}
				if [ ! -r $PKG_POOL/$PATCH_FILE ]; then
				   wget -c -P "$PKG_POOL"/partial "$PATCH_URL"
				   mv "$PKG_POOL"/partial/"$PATCH_FILE" "$PKG_POOL"
			   fi
				[ "${PATCH_FILE##*.}" = patch ] && patch -Np1 < $PKG_POOL/$PATCH_FILE
			done
			[ -x ${SPECS}/${PKG}/pre-build ] && ${SPECS}/${PKG}/pre-build
			popd
			touch .patched
		fi
		if [ ! -f .built ]; then
			pushd "$SRC_DIR"
			if [ -x ${SPECS}/${PKG}/build ]; then
				${SPECS}/${PKG}/build
			else
				if [ -r Makefile ] && [ ! -x configure ]; then
					make
					make install
					export MAKEDIR=$PWD
				elif [ -x configure ]; then
					export MAKEDIR=${PKG_DIR}/build
					if [ ! -f ${PKG_DIR}/.configured ]; then
						mkdir -p $MAKEDIR
						pushd $MAKEDIR
						$SRC_DIR/configure ${CONFIGFLAGS}
						popd
						touch ${PKG_DIR}/.configured
					fi
					cd $MAKEDIR
					make 
					make install
				elif [ -r ${PKG_NAME}.pro ]; then
					qmake
					make
					export MAKEDIR=$PWD
				else
					echo "Error: Don't know how to build package $PKG." >&2
					return 1
				fi
			fi
			popd
			touch .built
		fi
		if [ ! -f .done ]; then
			# post-install can be used to fix installation problems
			if [ -x ${SPECS}/${PKG}/post-install ]; then
				pushd /
				${SPECS}/${PKG}/post-install
				popd
			fi
			touch .done
		else
			echo "${PKG} has already been built. Skip."
			return
		fi
		)
	done
	echo -e "\nBuild complete."
}

make_clean_pkg()
{
	if ! grep -q '^clean' Makefile; then
		echo >&2 "Error: \"${PKG_NAME}\" does not support make clean"
		return 1
	fi
	make clean
	cd $PKG_DIR
	rm -f .done .built
}

make_distclean_pkg()
{
	if grep -q '^distclean' Makefile; then
		make distclean
	elif grep -q '^clean' Makefile; then
		make clean
	else
		echo >&2 "Error: \"${PKG_NAME}\" does not support make clean or distclean"
		return 1
	fi
	cd $PKG_DIR
	rm -f .done .built .configured
}

make_uninstall_pkg()
{
	if ! grep -q '^uninstall' Makefile; then
		echo >&2 "Error: \"${PKG_NAME}\" does not support make uninstall"
		return 1
	fi
	make uninstall
	rm -f $PKG_DIR/.done
}

make_install_tgt_pkg()
{
	if [ "$TARGET_INSTALL" = n ]; then
		echo "Package $PKG is not required to be installed on target."
		return
	fi
	[ -x $SPECS/$PKG/pre-install ] && $SPECS/$PKG/pre-install
	if [ $(basename ${PWD}) = 'build' ]; then
		make DESTDIR=${FS_ROOT} install
	elif [ "${PKG_NAME}" != "linux" ]; then
		make DESTDIR=${FS_ROOT} PREFIX=${FS_ROOT}${PREFIX} prefix=${FS_ROOT}${PREFIX} install
	fi
	# post-install can be used to fix target installation problems
	if [ -x ${SPECS}/${PKG}/post-install ]; then
		export DESTDIR="${FS_ROOT}" MAKEDIR="$PWD"
		pushd "$FS_ROOT"
		${SPECS}/${PKG}/post-install
		popd
		unset DESTDIR
	fi
}

remove_pkg()
{
	if [ -r "$PKG_POOL/$PKG_FILE_NAME" ] || [ -n "$PKG_URL" ]; then
		cd ..
		rm -rvf "$PKG_DIR"
	elif [ -d "$MAKEDIR" ]; then
		cd "$MAKEDIR"
		make_distclean_pkg
	fi
}

clean_pkgs()
{
	walk_build_dir make_clean_pkg
	echo -e "\nPackage ${BUILD_LIST[@]} clean complete."
}

distclean_pkgs()
{
	walk_build_dir -c make_distclean_pkg
	echo -e "\nPackage ${BUILD_LIST[@]} dist clean complete."
}

uninstall_pkgs()
{
	echo -e "\n${BUILD_LIST[@]} are going to be uninstalled.\n"
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_build_dir make_uninstall_pkg
	echo -e "\nPackage ${BUILD_LIST[@]} uninstall complete."
}

rebuild_pkgs()
{
	echo -e "\nRebuilding package(s) \"${BUILD_LIST[@]}\" ...\n"
	walk_pkg_dir -c remove_pkg
	build_pkgs
	echo -e "\nPackage(s) \"${BUILD_LIST[@]}\" rebuild complete."
}

strip_rootfs()
{
	OPATH=$PATH
	PATH=/tools/bin
	echo -e "\nStripping file system in $PWD ...\n"
	set +e
	find . -name "*.a" | xargs rm -rf
	find . -name "*.la" | xargs rm -rf
	find ./{,usr/}{,s}bin -type f 2> /dev/null | xargs strip --strip-all 2> /dev/null
	find ./{,usr/}lib -type f 2> /dev/null | xargs strip --strip-debug 2> /dev/null
	rm -rvf usr/share/{awk,doc,getopt,info,man,pkgconfig,readline,terminfo,vim} usr/{doc,info,man}
	set -e
	PATH=$OPATH
}

make_tgt_pkgs()
{
	build_pkgs
	pushd $FS_ROOT
	echo -e "\nCleaning ${FS_ROOT}\n"
	rm -rfv * .[!.]*
	if [ "$TARGET_pkgS" = all ] && declare -F configure_system &> /dev/null; then
		echo -e "\nConfiguring system in $PWD ...\n"
		configure_system
	fi
	echo -e "\nInstalling pkgs into ${FS_ROOT}\n"
	walk_build_dir make_install_tgt_pkg
	strip_rootfs
	popd
#	cd ${FS_ROOT}${BUILD_DEST}
#	sudo rm -rf include doc examples demos lib/dbus-1.0/include lib/glib-2.0/include share/doc share/gtk-doc
#	cd $FS_ROOT
#	sudo tar -pczvf $MECLOUD_BIN --numeric-owner --owner=root --group=root .
#	sudo chown $(id -ru):$(id -rg) $MECLOUD_BIN
	echo -e "\nRootFS generated in $FS_ROOT."
}

toolchain_link()
{
	pushd /tools/bin
	case "$1" in
		tools)
			ln -vf ld-old ld
			rm -vf `dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		root)
			ln -vf ld-new ld
			gcc -dumpspecs | sed -e 's@/tools@@g' \
				-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
				-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
				`dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		*)
			return 1
			;;
	esac
	popd
}

print_help_and_exit()
{
	exec >&2
	echo -e "Usage:\n $(basename $0) [Options] PackageName ..."
	echo "Options:"
	echo " -b, --local		Build locally, don't make target rootfs"
	echo " -f FILE, --config FILE	Specify your build config file (default: build.conf)"
	echo " -j N, --jobs N		Build with N jobs run concurrently"
	echo " --rebuild		Rebuild packages"
	echo " --clean		Clean packages"
	echo " --distclean		Dist clean package build directories and rootfs"
	echo " --uninstall		Uninstall package from build system"
	echo " -h			Print this help"
	echo "PackageName:"
	echo " \"all\"			Build all packages specified in SPECS/build_config"
	echo " \"package name\"		Single or multiple package names overriding build_config"
	exit
}

main()
{
	echo -e "Executing \"$0 $@\" at ${TIME}\n"
	mkdir -vp "$PACKAGES" "$FS_ROOT" "$PKG_POOL"/partial logs
	if declare -F configure_system > /dev/null && [ ! -f /.first_config ]; then
		pushd /
		configure_system
		touch /.first_config
		popd
	fi
	${ACTION:-make_tgt_pkgs}
}

GETOPTS=$(getopt -o bf:hj: --long clean,distclean,uninstall,rebuild,config:,jobs:,help -n "$0" -- "$@")
if [ $? != 0 ]; then
	print_help_and_exit
fi
eval set -- "$GETOPTS"
while true; do
	case "$1" in
		--clean)
			ACT=clean_pkgs; shift
			;;
		--distclean)
			ACT=distclean_pkgs; shift
			;;
		--uninstall)
			ACT=uninstall_pkgs; shift
			;;
		--rebuild)
			ACT=rebuild_pkgs; shift
			;;
		-b|--local)
			ACT=build_pkgs; shift
			;;
		-f|--config)
			BUILD_CONF="$2"; shift 2
			;;
		-j|--jobs)
			JOBS="$2"
			shift 2
			;;
		-h|--help)
			print_help_and_exit
			;;
		--)
			shift ; break
			;;
		*)
			print_help_and_exit
			;;
	esac
done

source ${BUILD_CONF:-~/build.conf}
for VAR in SPECS PACKAGES FS_ROOT PKG_POOL; do
	if [ -z "$(eval echo \$$VAR)" ]; then
		VAR_NOT_DEF+="$VAR "
		RET=1
	fi
done
if [ "$RET" = 1 ]; then
	echo "Error: Variable \"${VAR_NOT_DEF}\" must be defined in ${BUILD_CONF:-build.conf}" >&2
	return 1
fi

[ -n "$JOBS" ] && export MAKEFLAGS+="-j$JOBS"
[ -n "$ACT" ] && ACTION=$ACT
export -f toolchain_link

case "$@" in
	help | '')
		print_help_and_exit
		;;
	all)
		if [ "${#BUILD_LIST[@]}" = 0 ]; then
			echo "Error: No package to build. Please define BUILD_LIST in ${BUILD_CONF:-build.conf}" >&2
			return 1
		fi
		;;
	*)
		BUILD_LIST=($@)
		;;
esac

cd "$DEV_ROOT"
if [ ! -d "$SPECS" ]; then
	echo "Error: Directory \"$SPECS\" for SPECS found" >&2
	return 1
fi

trap quit ERR

main $@ 2>&1 | tee "$DEV_ROOT/logs/build-$TIME.log"
