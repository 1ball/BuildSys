#!/bin/bash
# Wenbo Wang (1ball.w@gmail.com)

TIME=$(date +%F-%X)

set -e
set -E
set -T

quit()
{
	echo "Build failed. Exiting..." >&2
	exit 1
}

trap -p quit ERR

unpack()
{
	if [ -n "$3" ]; then
		TGT_DIR="$3"
	else
		TGT_DIR=.
	fi
	case $2 in
		tar.gz | tar.bz2 | tar.xz)
			tar -xvf "$1" -C "$TGT_DIR"
			;;
		zip)
			unzip "$1" -d "$TGT_DIR"
			;;
		*)
			echo "Unkown package format for \"$1\"" >&2
			return 1
			;;
	esac
	return 0
}

guess_pkg_from_url()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$SUFFIX" in
			gz | bz2 | xz)
				SUFFIX="tar.$SUFFIX"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%.$SUFFIX}"
		PKG_NAME="${PKG_NAME%-*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$PKG_DIR" ]; then
		PKG_DIR="${SRC_DIR}/${PKG}/${PKG_NAME}-${VERSION}"
	else
		PKG_DIR="${SRC_DIR}/${PKG}/${PKG_DIR}"
	fi
	export PKG_FILE_NAME SUFFIX VERSION PKG_NAME PKG_DIR
}

walk_build_dir()
{
	local LOOP_ACTION='return'
	OPTIND=1
	while getopts "c" FLAG
	do
		case "$FLAG" in
			c)
				LOOP_ACTION='continue'
				;;
		esac
	done
	shift $((OPTIND - 1))
	for PKG in ${BUILD_LIST[@]}; do
		(
		set -e; set -E; set -T
		source ${SPECS}/${PKG}/spec
		[ -n "$PKG_URL" ] && guess_pkg_from_url "$PKG_URL"
		if [ -d "$SRC_DIR/$PKG/build" ]; then
			MAKEDIR="$SRC_DIR/$PKG/build"
		elif [ -d $PKG_DIR ]; then
			MAKEDIR="$PKG_DIR"
		else
			echo "Make directory for \"$PKG\" not found." >&2
			exit 1
		fi
		export PATCHES MAKEDIR
		pushd $MAKEDIR
		$@ || $LOOPACTION
		popd
		)
	done
}

build_apps()
{
	for PKG in ${BUILD_LIST[@]}; do
		if [ ! -r ${SPECS}/${PKG}/spec ]; then
			echo "Cannot read spec defined for package \"${PKG}\" in ${SPECS}/${PKG}" >&2
			exit 1
		fi
		(
		source ${SPECS}/${PKG}/spec
		[ -n "$PKG_URL" ] && guess_pkg_from_url "$PKG_URL"
		mkdir -p ${SRC_DIR}/${PKG}
		cd ${SRC_DIR}/${PKG}
		if [ ! -d "${PKG_DIR}" ]; then
			if [ ! -r "${PKG_FILE_NAME}" ] ; then
				if [ -n "$PKG_URL" ]; then
					wget $PKG_URL
				else
					echo "Package ${PKG_NAME}-${VERSION} not found." >&2
					exit 1
				fi
			fi
			unpack "${PKG_FILE_NAME}" $SUFFIX
		fi
		export PATCHES
		# Execute any script or binary: shell, perl, python, java, etc... with env variables exported to it
		# pre-build can be used to do patching job
		if [ ! -f .patched ]; then
			[ -r $SPECS/$PKG/*.patch ] && cp -v $SPECS/$PKG/*.patch .
			for PATCH_URL in ${PATCHES[@]}; do
				PATCH_FILE=${PATCH_URL##*/}
				[ ! -r $PATCH_FILE ] && wget $PATCH_URL
			done
			if ls *.patch &> /dev/null; then
				pushd "$PKG_DIR"
				for PATCH_FILE in ../*.patch; do
					patch -Np1 < $PATCH_FILE
				done
				popd
			fi
			[ -x ${SPECS}/${PKG}/pre-build ] && ${SPECS}/${PKG}/pre-build
			touch .patched
		fi
		if [ ! -f .built ]; then
			pushd "$PKG_DIR"
			if [ -x ${SPECS}/${PKG}/build ]; then
				${SPECS}/${PKG}/build
			else
				if [ -r Makefile ] && [ ! -x configure ]; then
					make
					make install
				elif [ -x configure ]; then
					if [ ! -f ../.configured ]; then
						mkdir -p ../build
						pushd ../build
						$PKG_DIR/configure ${CONFIGFLAGS}
						popd
						touch ../.configured
					fi
					cd ../build
					make 
					make install
				elif [ -r ${PKG_NAME}.pro ]; then
					qmake
					make
				else
					echo "Don't know how to build package $PKG." >&2
					exit 1
				fi
			fi
			popd
			touch .built
		fi
		if [ ! -f .done ]; then
			# post-install can be used to fix installation problems
			if [ -x ${SPECS}/${PKG}/post-install ]; then
				[ -d build ] && cd build
				export MAKEDIR=$PWD
				pushd /
				${SPECS}/${PKG}/post-install
				popd
				unset MAKEDIR
			fi
			touch .done
		else
			echo "${PKG} has already been built. Skip."
			exit
		fi
		)
	done
	echo -e "\nBuild complete."
}

make_clean_app()
{
	make clean
	cd $PKG_DIR
	rm -f .done .built
}

make_distclean_app()
{
	make DESTDIR=$FS_ROOT uninstall
	make distclean || make clean
	cd $PKG_DIR
	rm -f .done .built .configured
}

make_uninstall_app()
{
	make uninstall
	rm -f $PKG_DIR/.done
}

make_install_tgt_app()
{
	if [ "$TARGET_INSTALL" = n ]; then
		echo "Package $PKG is not required to be installed on target."
		return
	fi
	[ -x $SPECS/$PKG/pre-install ] && $SPECS/$PKG/pre-install
	if [ $(basename ${PWD}) = 'build' ]; then
		make DESTDIR=${FS_ROOT} install
	elif [ "${PKG_NAME}" != "linux" ]; then
		make DESTDIR=${FS_ROOT} PREFIX=${FS_ROOT}${PREFIX} prefix=${FS_ROOT}${PREFIX} install
	fi
	# post-install can be used to fix target installation problems
	if [ -x ${SPECS}/${PKG}/post-install ]; then
		export DESTDIR="${FS_ROOT}" MAKEDIR="$PWD"
		pushd "$FS_ROOT"
		${SPECS}/${PKG}/post-install
		popd
		unset DESTDIR
	fi
}

clean_apps()
{
	walk_build_dir make_clean_app
	echo -e "\nPackage ${BUILD_LIST[@]} clean complete."
}

distclean_apps()
{
	walk_build_dir -c make_distclean_app
	echo -e "\nPackage ${BUILD_LIST[@]} dist clean complete."
}

uninstall_apps()
{
	echo -e "\n${BUILD_LIST[@]} are going to be uninstalled.\n"
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_build_dir make_uninstall_app
	echo -e "\nPackage ${BUILD_LIST[@]} uninstall complete."
}

strip_rootfs()
{
	OPATH=$PATH
	PATH=/tools/bin
	echo -e "\nStripping file system in $PWD ...\n"
	set +e
	find . -name "*.a" | xargs rm -rf
	find . -name "*.la" | xargs rm -rf
	find ./{,usr/}{,s}bin -type f 2> /dev/null | xargs strip --strip-all 2> /dev/null
	find ./{,usr/}lib -type f 2> /dev/null | xargs strip --strip-debug 2> /dev/null
	rm -rvf usr/share/{awk,doc,getopt,info,man,pkgconfig,readline,terminfo,vim} usr/{doc,info,man}
	set -e
	PATH=$OPATH
}

make_tgt_apps()
{
	build_apps ${BUILD_LIST[@]}
	pushd $FS_ROOT
	echo -e "\nCleaning ${FS_ROOT}\n"
	rm -rfv * .[!.]*
	if [ "$TARGET_APPS" = all ] && declare -F configure_system &> /dev/null; then
		echo -e "\nConfiguring system in $PWD ...\n"
		configure_system
	fi
	echo -e "\nInstalling apps into ${FS_ROOT}\n"
	walk_build_dir make_install_tgt_app
	strip_rootfs
	popd
#	cd ${FS_ROOT}${BUILD_DEST}
#	sudo rm -rf include doc examples demos lib/dbus-1.0/include lib/glib-2.0/include share/doc share/gtk-doc
#	cd $FS_ROOT
#	sudo tar -pczvf $MECLOUD_BIN --numeric-owner --owner=root --group=root .
#	sudo chown $(id -ru):$(id -rg) $MECLOUD_BIN
	echo -e "\nRootFS generated in $FS_ROOT."
}

init_env()
{
	source ${BUILD_CONF:-build.conf}
	cd "$DEV_ROOT"
	if [ ! -d SPEC ]; then
		echo "No SPEC directory found" >&2
		exit 1
	fi
	mkdir -vp "$SRC_DIR" "$FS_ROOT" logs
	if [ ! -f /.first_config ]; then
		pushd /
		configure_system
		touch /.first_config
		popd
	fi
}

print_help_and_exit()
{
	exec >&2
	echo "Usage: $(basename $0) [Options] [Package Name]"
	echo "Options can be:"
	echo "	-f		Specify your build config file (default: build.conf)"
	echo "	-b		Build only, don't make rootfs"
	echo "	--clean		Clean packages"
	echo "	--distclean		Dist clean package build directories and rootfs"
	echo "	-i <directory>	Install package to <directory>"
	echo "	--uninstall		Uninstall package from build system (Caution: this may break build system)"
	echo "	-h		Print this help"
	echo "Target can be:"
	echo "	\"all\" - Build all packages specified in SPECS/build_config"
	echo "	\"package name\" - Single or multiple package names overriding build_config"
	exit
}

main()
{
	echo -e "Executing $0 $@ at ${TIME}\n"
	GETOPTS=$(getopt -o bf:h --long clean,distclean,uninstall,config:,help -n "$0" -- "$@")
	[ $? != 0 ] && print_help_and_exit
	eval set -- "$GETOPTS"
	while true; do
		case "$1" in
			-b)
				ACTION=build_apps; shift
				;;
			--clean)
				ACTION=clean_apps; shift
				;;
			--distclean)
				ACTION=distclean_apps; shift
				;;
			-f|--config)
				BUILD_CONF="$2"; shift 2
				;;
			--uninstall)
				ACTION=uninstall_apps; shift
				;;
			-h|--help)
				print_help_and_exit
				;;
			--)
				shift ; break
				;;
			*)
				print_help_and_exit
				;;
		esac
	done
	TARGET_APPS="$@"
	case "$TARGET_APPS" in
		help | '')
			print_help_and_exit
			;;
		all)
			if [ "${#BUILD_LIST[@]}" = 0 ]; then
				echo "No package to build. Please define BUILD_LIST in ${BUILD_CONF}" >&2
				exit 1
			fi
			;;
		*)
			BUILD_LIST=($@)
			;;
	esac

	${ACTION:-make_tgt_apps}
}

init_env
main $@ 2>&1 | tee "$DEV_ROOT/logs/build-$TIME.log"
