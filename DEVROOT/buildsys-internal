#!/tools/bin/bash

set -eE

export SDKARCH=$ARCH
if [ "$ARCH" = i686 ]; then
	set +h
	unset ARCH
else
	set -h
	export ARCH
fi

START_TIME=$(date +%F-%X)
OPTS_ORIG="$@"

bs_error()
{
	echo -e "!!!!!!!! Error: $@ !!!!!!!!!!" >&2
}

bs_notice()
{
	echo -e ">>>>>>>>> $@ <<<<<<<<<<"
}

quit()
{
	bs_error "buildsys process interrupted..."
	exit 1
}

unpack()
{
	local DEST='.'
	if [ -n "$2" ]; then
		DEST="$2"
	fi
	case "$1" in
		*.tar.gz | *.tar.bz2 | *.tar.xz | *.tgz | *.tbz | *.txz)
			tar -xf "$1" -C "$DEST"
			;;
		*.zip)
			unzip "$1" -d "$DEST"
			;;
		*)
			bs_error "Unknown package format for \"$1\""
			return 1
			;;
	esac
	return 0
}

guess_pkg_info()
{
	[ -z "$1" ] && return 1

	if [ -z "$PKG_FILE_NAME" ]; then
		PKG_FILE_NAME="${1##*/}"
	fi
	if [ -z "$SUFFIX" ]; then
		SUFFIX="${PKG_FILE_NAME##*.}"
		case "$PKG_FILE_NAME" in
			*.tar.gz | *.tar.bz2 | *.tar.xz)
				SUFFIX="tar.$SUFFIX"
				;;
		esac
	fi
	if [ -z "$VERSION" ]; then
		VERSION="${PKG_FILE_NAME%.$SUFFIX}"
		VERSION="${VERSION##*-}"
	fi
	if [ -z "$PKG_NAME" ]; then
		PKG_NAME="${PKG_FILE_NAME%.$SUFFIX}"
		PKG_NAME="${PKG_NAME%-*}"
		[ -z "$PKG_NAME" ] && PKG_NAME="$PKG"
	fi
	if [ -z "$SRC_DIR" ]; then
		SRC_DIR="${PACKAGES}/${PKG}/${PKG_NAME}-${VERSION}"
	else
		SRC_DIR="${PACKAGES}/${PKG}/${SRC_DIR}"
	fi
}

get_file()
{
	local SOURCE="$1" DEST="$2"
	local SOURCE_FILE="${SOURCE##*/}"
	if [ -f "$DEST"/"$SOURCE_FILE" ]; then
		bs_notice "File \"$SOURCE_FILE\" already exists in \"$DEST\", skip getting"
		return
	fi
	case "$SOURCE" in
		http://*)
			;&
		ftp://*)
			bs_notice "Downloading ${SOURCE}"
			wget -c -O "$DEST/${SOURCE_FILE}.partial" "$SOURCE"
			mv "$DEST"/${SOURCE_FILE}.partial "$DEST"/$SOURCE_FILE
			;;
		*)
			if [ -f "$SOURCE" ]; then
				ln -v "$SOURCE" "$DEST"
			else
				bs_error "File \"$SOURCE\" not found"
				return 1
			fi
			;;
	esac
}

walk_pkg_dir()
{
	SETOPTS='-eET'
	OPTIND=1
	while getopts "c" FLAG
	do
		case "$FLAG" in
			c)
				SETOPTS=''
				;;
		esac
	done
	shift $((OPTIND - 1))
	for PKG in ${BUILD_LIST[@]}; do
		(
		set -a $SETOPTS
		source ${SPECS}/${PKG}/spec
		[ -n "$PKG_LOCATION" ] && guess_pkg_info "$PKG_LOCATION"
		PKG_DIR="${PACKAGES}/${PKG}"
		mkdir -p "$PKG_DIR"
		if [ -d "$PKG_DIR/build" ]; then
			MAKEDIR="$PKG_DIR/build"
		elif [ -d "$SRC_DIR" ]; then
			MAKEDIR="$SRC_DIR"
		fi
		pushd "$PKG_DIR"
		for ACT in "$@"; do
			$ACT
		done
		popd
		)
	done
}

pkg_unpack_patch()
{
	if [ ! -f .unpacked ] && [ ! -d "${SRC_DIR}" ]; then
		if [ -z "$PKG_LOCATION" ]; then
			bs_error "No source file defined for \"$PKG\""
			return 1
		else
			get_file "$PKG_LOCATION" "$PKG_POOL"
		fi
		bs_notice "Unpacking file ${PKG_FILE_NAME}"
		unpack "${PKG_POOL}/${PKG_FILE_NAME}"
		for ADDITION in ${ADDITIONS[@]}; do
			get_file "$ADDITION" "$PKG_POOL"
			unpack "$PKG_POOL/${ADDITION##*/}" "$SRC_DIR"
		done
		touch .unpacked
	fi
	if [ ! -f .patched ]; then
		pushd "$SRC_DIR"
		for PATCH in ${PATCHES[@]}; do
			get_file "$PATCH" "$PKG_POOL"
			patch -Np1 < $PKG_POOL/${PATCH##*/}
		done
		# Execute any script or binary with env variables exported for it
		# pre-build can be used to do patching job
		# Only bash and perl supported for scripting as of now
		[ -x ${SPECS}/${PKG}/pre-build ] && ${SPECS}/${PKG}/pre-build
		popd
		touch .patched
	fi
}

pkg_make_install()
{
	if [ ! -f .built ]; then
		pushd "$SRC_DIR"
		bs_notice "Building package ${PKG} in $SRC_DIR"
		if [ -x ${SPECS}/${PKG}/build ]; then
			${SPECS}/${PKG}/build
		else
			if [ -r Makefile ] && [ ! -x configure ]; then
				make
				make PREFIX="$PREFIX" install
				MAKEDIR=$PWD
			elif [ -x configure ]; then
				MAKEDIR=${PKG_DIR}/build
				if [ ! -f ${PKG_DIR}/.configured ]; then
					mkdir -p $MAKEDIR
					pushd $MAKEDIR
					$SRC_DIR/configure --prefix="$PREFIX" $CROSSCONFOPTS ${CONFIGFLAGS}
					popd
					touch ${PKG_DIR}/.configured
				fi
				cd $MAKEDIR
				make 
				make install
			elif [ -r ${PKG_NAME}.pro ]; then
				qmake
				make
				MAKEDIR=$PWD
			else
				bs_error "Don't know how to build package $PKG."
				return 1
			fi
		fi
		popd
		touch .built
	fi
	if [ ! -f .done ]; then
		# post-install can be used to fix installation problems
		if [ -x ${SPECS}/${PKG}/post-install ]; then
			pushd /
			${SPECS}/${PKG}/post-install
			popd
		fi
		touch .done
	else
		bs_notice "${PKG} has already been built. Skip."
		return
	fi
}

pkg_make_clean()
{
	cd $MAKEDIR
	if ! grep -q '^clean:' Makefile; then
		bs_error "\"${PKG_NAME}\" does not support make clean"
		return 1
	fi
	bs_notice "Cleaing \"$PKG\"..."
	make clean
	cd $PKG_DIR
	rm -f .done .built
}

pkg_make_distclean()
{
	cd $MAKEDIR
	bs_notice "Dist cleaing \"$PKG\"..."
	if grep -q '^distclean:' Makefile; then
		make distclean
	elif grep -q '^clean:' Makefile; then
		make clean
	else
		bs_error "\"${PKG_NAME}\" does not support make clean or distclean"
		return 1
	fi
	cd $PKG_DIR
	rm -f .done .built .configured
}

pkg_make_uninstall()
{
	cd $MAKEDIR
	if ! grep -q '^uninstall' Makefile; then
		bs_error "Error: \"${PKG_NAME}\" does not support make uninstall"
		return 1
	fi
	bs_notice "Uninstalling \"$PKG\"..."
	make uninstall
	rm -f $PKG_DIR/.done
}

pkg_make_dest_install()
{
	if [ "$TARGET_INSTALL" = n ]; then
		bs_notice "Package \"$PKG\" is not required to be installed on target."
		return
	fi
	bs_notice "Installing \"$PKG\" into ${FS_ROOT}..."
	cd $MAKEDIR
	[ -x $SPECS/$PKG/pre-install ] && $SPECS/$PKG/pre-install
	if [ $(basename ${PWD}) = 'build' ]; then
		make DESTDIR=${FS_ROOT} install
	elif [ "${PKG_NAME}" != "linux" ]; then
		make DESTDIR=${FS_ROOT} PREFIX=${FS_ROOT}/${PREFIX} prefix=${FS_ROOT}/${PREFIX} install
	fi
	# post-install can be used to fix target installation problems
	if [ -x ${SPECS}/${PKG}/post-install ]; then
		MAKEDIR="$PWD"
		pushd "$FS_ROOT"
		${SPECS}/${PKG}/post-install
		popd
	fi
}

pkg_remove()
{
	if [ -r "$PKG_POOL/$PKG_FILE_NAME" ] || [ -n "$PKG_LOCATION" ]; then
		cd ..
		bs_notice "Removing $PKG_DIR"
		rm -rf "$PKG_DIR"
	elif [ -d "$MAKEDIR" ]; then
		pkg_make_distclean
	fi
}

clean_pkgs()
{
	walk_pkg_dir pkg_make_clean
	bs_notice "Package ${BUILD_LIST[@]} clean complete."
}

distclean_pkgs()
{
	walk_pkg_dir -c pkg_make_distclean
	bs_notice "Package ${BUILD_LIST[@]} dist clean complete."
}

uninstall_pkgs()
{
	bs_notice "${BUILD_LIST[@]} are going to be uninstalled."
	while true; do
		echo -n "Proceed uninstall? (y/n) "
		read ANSWER
		case "$ANSWER" in
			n | N | no | NO)
				echo "Uninstall canceled."
				return
				;;
			y | Y | yes | YES)
				break
				;;
			*)
				;;
		esac
	done
	walk_pkg_dir pkg_make_uninstall
	bs_notice "Package ${BUILD_LIST[@]} uninstall complete."
}

build_pkgs()
{
	bs_notice "Start building package(s) \"${BUILD_LIST[@]}\"..."
	walk_pkg_dir pkg_unpack_patch pkg_make_install
	bs_notice "Build complete"
}

rebuild_pkgs()
{
	bs_notice "Rebuilding package(s) \"${BUILD_LIST[@]}\"..."
	walk_pkg_dir -c pkg_remove
	walk_pkg_dir pkg_unpack_patch pkg_make_install
	bs_notice "Package(s) \"${BUILD_LIST[@]}\" rebuild complete."
}

unpack_pkgs()
{
	bs_notice "Unpacking package(s) \"${BUILD_LIST[@]}\"..."
	walk_pkg_dir pkg_unpack_patch
	bs_notice "Package(s) \"${BUILD_LIST[@]}\" unpack complete."
}

strip_rootfs()
{
	OPATH=$PATH
	PATH=/tools/bin
	bs_notice "Stripping file system in ${PWD}..."
	find . -name "*.a" | xargs rm -rf
	find . -name "*.la" | xargs rm -rf
	find ./{,usr/}{,s}bin -type f 2> /dev/null | xargs strip --strip-all 2> /dev/null
	find ./{,usr/}lib -type f 2> /dev/null | xargs strip --strip-debug 2> /dev/null
	rm -rvf usr/share/{awk,doc,getopt,info,man,pkgconfig,readline,terminfo,vim} usr/{doc,info,man}
	PATH=$OPATH
}

install_tgt_pkgs()
{
	pushd $FS_ROOT
	bs_notice "Cleaning ${FS_ROOT}"
	rm -rf * .[!.]*
	if [ -z "$TARGET_PKGS" ] || [ "$TARGET_PKGS" = all ] && declare -F configure_system &> /dev/null; then
		bs_notice "Configuring system in ${PWD}..."
		configure_system
	fi
	walk_pkg_dir pkg_unpack_patch pkg_make_install pkg_make_dest_install
	set +eE
	strip_rootfs
	set -eE
	popd
#	cd ${FS_ROOT}${BUILD_DEST}
#	sudo rm -rf include doc examples demos lib/dbus-1.0/include lib/glib-2.0/include share/doc share/gtk-doc
#	cd $FS_ROOT
#	sudo tar -pczvf $MECLOUD_BIN --numeric-owner --owner=root --group=root .
#	sudo chown $(id -ru):$(id -rg) $MECLOUD_BIN
	bs_notice "RootFS generated in $FS_ROOT"
}

toolchain_link()
{
	pushd /tools/bin
	case "$1" in
		tools)
			ln -vf ld-old ld
			rm -vf `dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		root)
			ln -vf ld-new ld
			gcc -dumpspecs | sed -e 's@/tools@@g' \
				-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
				-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
				`dirname $(gcc --print-libgcc-file-name)`/specs
			;;
		*)
			return 1
			;;
	esac
	popd
}

print_help_and_exit()
{
	exec >&2
	echo -e "Usage:\n $(basename $0) [Options] Command PackageName ..."
	echo "Options:"
	echo " -f FILE, --config FILE	Use FILE as build config"
	echo "			(default: build-${SDKARCH:-i686}.conf)"
	echo " -j N, --jobs N		Build with N jobs running concurrently"
	echo " -h, --help		Print this help"
	echo "Command:"
	echo " unpack			Unpack only, don't build the package"
	echo " build			Unpack and build only, don't make target rootfs"
	echo " install		Build and install packages into dest root directory"
	echo "			(This is default if no Command specified)"
	echo " clean			Clean packages"
	echo " distclean		Dist clean package build directories and rootfs"
	echo " uninstall		Uninstall package from root directory in SDE"
	echo " rebuild		Clean up and then rebuild packages"
	echo "PackageName:"
	echo " \"all\"			Build all packages specified in config file"
	echo "			(default all for empty PackageName)"
	echo " \"package name\"		Single or multiple package names overriding config file"
	exit
}

main()
{
	echo "Executing \"$0 $OPTS_ORIG\" with ${BUILD_CONF} at ${START_TIME}"
	mkdir -vp "$PACKAGES" "$FS_ROOT" "$PKG_POOL" logs
	if declare -F configure_system > /dev/null && [ ! -f /.first_config ]; then
		pushd /
		configure_system
		touch /.first_config
		popd
	fi
	${ACTION:-install_tgt_pkgs}
}

[ -n "$DEV_ROOT" ] && export DEV_ROOT INCDIR="$DEV_ROOT/INC"

GETOPTS=$(getopt -o f:j:h --long config:,jobs:,help -n "$0" -- "$@")
[ $? != 0 ] && print_help_and_exit

eval set -- "$GETOPTS"
while true; do
	case "$1" in
		-f|--config)
			BUILD_CONF="$2"
			if [ ! -f "$BUILD_CONF" ]; then
				BUILD_CONF="$INCDIR/${BUILD_CONF##*/}"
			fi
			if [ ! -f "$BUILD_CONF" ]; then
				bs_error "File \"$2\" not found"
				exit 1
			fi
			shift 2
			;;
		-j|--jobs)
			JOBS="$2"
			shift 2
			;;
		-h|--help)
			print_help_and_exit
			;;
		--)
			shift ; break
			;;
		*)
			print_help_and_exit
			;;
	esac
done

if [ ! -d "$INCDIR" ]; then
	bs_error "Directory \"$INCDIR\" for global configuration not found"
	return 1
fi

set -a
source ${BUILD_CONF:="$INCDIR/build-${SDKARCH}.conf"}
set +a

for VAR in PACKAGES FS_ROOT PKG_POOL; do
	if [ -z "$(eval echo \$$VAR)" ]; then
		VAR_NOT_DEF+="$VAR "
		RET=1
	fi
done

if [ "$RET" = 1 ]; then
	bs_error "Variable \"${VAR_NOT_DEF}\" must be defined in ${BUILD_CONF}"
	return 1
fi

if [ "$ARCH" = arm ]; then
	CROSSCONFOPTS="--build=i686-pc-linux-gnu --host=arm-buildsys-linux-gnueabi"
fi

[ -n "$JOBS" ] && export MAKEFLAGS+="-j$JOBS"
export -f toolchain_link

case "$1" in
	clean)
		ACTION=clean_pkgs; shift
		;;
	distclean)
		ACTION=distclean_pkgs; shift
		;;
	uninstall)
		ACTION=uninstall_pkgs; shift
		;;
	rebuild)
		ACTION=rebuild_pkgs; shift
		;;
	unpack)
		ACTION=unpack_pkgs; shift
		;;
	build)
		ACTION=build_pkgs; shift
		;;
	install)
		ACTION=install_tgt_pkgs; shift
		;;
	help)
		print_help_and_exit
		;;
esac

TARGET_PKGS="$@"
case "$TARGET_PKGS" in
	all|'')
		if [ "${#BUILD_LIST[@]}" = 0 ]; then
			bs_error "No package to build. Please define BUILD_LIST in ${BUILD_CONF}"
			return 1
		fi
		;;
	*)
		BUILD_LIST=($@)
		;;
esac

cd "$DEV_ROOT"
if [ ! -d "${SPECS:-$DEV_ROOT/SPECS}" ]; then
	bs_error "Directory \"$SPECS\" for SPECS not found"
	return 1
fi

trap quit ERR

main $@ 2>&1 | tee "$DEV_ROOT/logs/build-$START_TIME.log"
